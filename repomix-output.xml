This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.continue/agents/new-config.yaml
.env,local
.firebaserc
.gitignore
app/actions/consumeItem.ts
app/actions/createPrinted.ts
app/actions/importStl.ts
app/actions/reportDefect.ts
app/actions/updateItemStatus.ts
app/actions/updateProcess.ts
app/api/import-stl/route.ts
app/api/preview-filenames/route.ts
app/components/CartModal.tsx
app/components/common/FileDownloadButton.tsx
app/components/ModelViewer.tsx
app/components/PreviewModal.tsx
app/components/StlImportModal.tsx
app/components/SummaryCard.tsx
app/components/swimlane/SwimlaneCell.tsx
app/components/swimlane/SwimlaneItem.tsx
app/components/swimlane/SwimlaneRow.tsx
app/constants.ts
app/data.ts
app/globals.css
app/item/[id]/page.tsx
app/layout.tsx
app/page.tsx
app/print/page.tsx
app/project/[id]/page.tsx
app/project/[id]/ProjectClientContent.tsx
app/types.ts
app/utils.ts
docs/INTEGRATION_EXAMPLE.md
docs/STL_IMPORT_GUIDE.md
firebase-data/auth_export/accounts.json
firebase-data/auth_export/config.json
firebase-data/firebase-export-metadata.json
firebase-data/firestore_export/all_namespaces/all_kinds/all_namespaces_all_kinds.export_metadata
firebase-data/firestore_export/all_namespaces/all_kinds/output-0
firebase-data/firestore_export/firestore_export.overall_export_metadata
firebase-data/storage_export/blobs/962b3f69-c119-415e-9e0b-7214764838df
firebase-data/storage_export/buckets.json
firebase-data/storage_export/metadata/962b3f69-c119-415e-9e0b-7214764838df.json
firebase.json
firestore.indexes.json
firestore.rules
lib/firebase.ts
lib/mockStore.ts
lib/utils/parseFileName.ts
next.config.js
package.json
postcss.config.js
public/models/PART-A.stl
README.md
scripts/seed-emulator.ts
tailwind.config.js
tsconfig.json
tsconfig.node.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/components/swimlane/SwimlaneCell.tsx">
import React from 'react';
import { useDroppable } from '@dnd-kit/core';
import { SortableContext, verticalListSortingStrategy } from '@dnd-kit/sortable';
import { PartItem, ProcessStatus } from '@/app/types';
import { SwimlaneItem } from './SwimlaneItem';
import { Check, Circle } from 'lucide-react';

interface SwimlaneCellProps {
    partId: number;
    status: ProcessStatus;
    statusName: string;
    items: PartItem[];
    isLast: boolean;
    statusState: 'active' | 'completed' | 'pending';
    onPreview: (item: any) => void;
}

export function SwimlaneCell({ partId, status, statusName, items, isLast, statusState, onPreview }: SwimlaneCellProps) {
    const droppableId = `container-${partId}-${status}`;
    const { setNodeRef, isOver } = useDroppable({ id: droppableId });

    // Status-specific styling
    const getStatusColor = (s: string) => {
        switch (s) {
            case 'ASSEMBLED': return 'text-green-600 bg-green-50 border-green-200';
            case 'DEFECTIVE': return 'text-red-600 bg-red-50 border-red-200';
            case 'UNPRINTED': return 'text-gray-400 bg-gray-50 border-gray-200';
            default: return 'text-blue-600 bg-blue-50 border-blue-200';
        }
    };

    const isActive = statusState === 'active';
    const isCompleted = statusState === 'completed';
    const statusColor = getStatusColor(status);

    return (
        <div className="flex gap-3 relative">
            {/* Timeline Column */}
            <div className="flex flex-col items-center min-w-[24px]">
                {/* Connector Line */}
                {!isLast && (
                    <div className={`absolute top-6 bottom-0 w-0.5 -z-10 ${isCompleted ? 'bg-blue-300' : 'bg-gray-200'}`} />
                )}

                {/* Status Check/Dot */}
                <div className={`
          w-6 h-6 rounded-full flex items-center justify-center border-2 z-10 bg-white transition-colors
          ${isActive ? 'border-blue-500 text-blue-500 shadow-md scale-110' : ''}
          ${isCompleted ? 'border-blue-500 bg-blue-500 text-white' : ''}
          ${!isActive && !isCompleted ? 'border-gray-200 text-gray-300' : ''}
        `}>
                    {isCompleted ? (
                        <Check size={14} strokeWidth={3} />
                    ) : isActive ? (
                        <div className="w-2.5 h-2.5 bg-blue-500 rounded-full animate-pulse" />
                    ) : (
                        <div className="w-2 h-2 bg-gray-200 rounded-full" />
                    )}
                </div>
            </div>

            {/* Content Column */}
            <div className="flex-1 pb-6 w-full min-w-0"> {/* Padding bottom for spacing between steps */}
                <div className="flex items-center justify-between mb-2">
                    <span className={`text-xs font-bold uppercase tracking-wider ${isActive ? 'text-blue-700' : 'text-gray-400'}`}>
                        {statusName}
                    </span>
                    <span className="text-[10px] text-gray-400 bg-gray-100 px-1.5 rounded-full">
                        {items.length}
                    </span>
                </div>

                <div
                    ref={setNodeRef}
                    className={`
            min-h-[60px] rounded-lg border-2 border-dashed transition-colors p-2
            ${isOver ? 'bg-blue-50 border-blue-300' : 'border-gray-100 bg-gray-50/30'}
            ${items.length === 0 && !isOver ? 'hover:border-gray-200' : ''}
          `}
                >
                    <SortableContext
                        items={items.map(i => `item-${i.id}`)}
                        strategy={verticalListSortingStrategy}
                    >
                        {items.length > 0 ? (
                            <div className="flex flex-col gap-2">
                                {items.map(item => (
                                    <SwimlaneItem key={item.id} item={item} onPreview={onPreview} />
                                ))}
                            </div>
                        ) : (
                            <div className="h-full flex items-center justify-center">
                                <span className="text-[10px] text-gray-300 font-medium select-none">
                                    Drop Here
                                </span>
                            </div>
                        )}
                    </SortableContext>
                </div>
            </div>
        </div>
    );
}
</file>

<file path="app/components/swimlane/SwimlaneItem.tsx">
import React from 'react';
import { useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { GripVertical, Eye } from 'lucide-react';
import { PartItem } from '@/app/types';

interface SwimlaneItemProps {
    item: PartItem & { part_number?: string };
    isOverlay?: boolean;
    onPreview: (item: any) => void;
}

export function SwimlaneItem({ item, isOverlay, onPreview }: SwimlaneItemProps) {
    const {
        attributes,
        listeners,
        setNodeRef,
        transform,
        transition,
        isDragging
    } = useSortable({ id: `item-${item.id}` });

    const style = {
        transform: CSS.Transform.toString(transform),
        transition,
        opacity: isDragging ? 0.3 : 1,
        zIndex: isDragging || isOverlay ? 999 : 'auto',
    };

    return (
        <div
            ref={setNodeRef}
            style={style}
            className={`
        bg-white rounded-lg shadow-sm border border-gray-200 p-2 mb-2 select-none group relative
        ${isOverlay ? 'shadow-xl scale-105 border-blue-500 ring-2 ring-blue-200' : 'hover:border-blue-400'}
      `}
        >
            <div className="flex items-center justify-between gap-2">
                {/* Drag Handle - Mobile/Touch Target */}
                <div
                    {...attributes}
                    {...listeners}
                    className="cursor-grab active:cursor-grabbing p-1 -ml-1 text-gray-400 hover:text-gray-600 touch-none"
                >
                    <GripVertical size={16} />
                </div>

                {/* Item Content */}
                <div className="flex-1 min-w-0">
                    <div className="flex items-center gap-2">
                        <span className="font-bold text-xs text-gray-700">#{item.id}</span>
                        {item.storage_case && (
                            <span className="text-[10px] px-1.5 py-0.5 bg-gray-100 rounded text-gray-500 truncate max-w-[80px]">
                                {item.storage_case}
                            </span>
                        )}
                    </div>
                </div>

                {/* Action Buttons */}
                <button
                    onClick={(e) => {
                        e.stopPropagation();
                        onPreview(item);
                    }}
                    className="text-gray-400 hover:text-blue-600 p-1 rounded hover:bg-blue-50 transition-colors"
                    title="詳細を見る"
                >
                    <Eye size={14} />
                </button>
            </div>

            {/* Date or extra info if needed */}
            {item.updated_at && (
                <div className="text-[10px] text-gray-400 mt-1 pl-6">
                    {new Date(item.updated_at).toLocaleDateString()}
                </div>
            )}
        </div>
    );
}
</file>

<file path="app/components/swimlane/SwimlaneRow.tsx">
import React from 'react';
import { Download } from 'lucide-react';
import { Part, PartItem } from '@/app/types';
import { PROCESSES } from '@/app/constants';
import { SwimlaneCell } from './SwimlaneCell';
import FileDownloadButton from '@/app/components/common/FileDownloadButton';

interface SwimlaneRowProps {
    part: Part;
    items: PartItem[];
    onPreview: (item: any) => void;
}

export function SwimlaneRow({ part, items, onPreview }: SwimlaneRowProps) {
    // Sort processes based on the constant order
    const sortedProcesses = PROCESSES;

    return (
        <div className="
      group relative flex flex-col
      w-[85vw] md:w-80 shrink-0 snap-center
      bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden
      transition-shadow hover:shadow-md
    ">
            {/* Sticky Header */}
            <div className="sticky top-0 z-20 bg-gray-50/95 backdrop-blur-sm border-b border-gray-200 p-4">
                <div className="flex justify-between items-start mb-2">
                    <div>
                        <h3 className="font-bold text-gray-800 text-lg leading-tight truncate" title={part.part_number}>
                            {part.part_number}
                        </h3>
                        <span className="text-xs text-gray-500 font-medium bg-gray-200 px-2 py-0.5 rounded-full inline-block mt-1">
                            Total: {items.length} unit{items.length !== 1 ? 's' : ''}
                        </span>
                    </div>
                    <FileDownloadButton
                        storagePath={`models/${part.part_number}.stl`}
                        fileName={`${part.part_number}_model.stl`}
                        label="STL"
                        variant="outline"
                    />
                </div>

                {/* Progress Bar (Optional Visual Flair) */}
                <div className="w-full h-1 bg-gray-200 rounded-full overflow-hidden mt-2">
                    <div
                        className="h-full bg-blue-500 transition-all duration-500"
                        style={{
                            width: `${(items.filter(i => i.status === 'ASSEMBLED').length / (items.length || 1)) * 100}%`
                        }}
                    />
                </div>
            </div>

            {/* Vertical Timeline Body */}
            <div className="flex-1 overflow-y-auto p-4 space-y-0 bg-white">
                {sortedProcesses.map((proc, index) => {
                    const itemsHere = items.filter(i => i.status === proc.key).length;

                    // Check if any items are ahead of this process
                    const itemsAhead = items.filter(i => {
                        const itemStatusIndex = sortedProcesses.findIndex(p => p.key === i.status);
                        // If status not found (e.g. DEFECTIVE), treat as not ahead
                        return itemStatusIndex > index;
                    }).length;

                    let statusState: 'active' | 'completed' | 'pending' = 'pending';
                    if (itemsHere > 0) {
                        statusState = 'active';
                    } else if (itemsAhead > 0) {
                        statusState = 'completed';
                    }

                    return (
                        <SwimlaneCell
                            key={proc.key}
                            partId={part.id}
                            status={proc.key}
                            statusName={proc.name}
                            items={items.filter(i => i.status === proc.key)}
                            isLast={index === sortedProcesses.length - 1}
                            statusState={statusState}
                            onPreview={onPreview}
                        />
                    );
                })}
            </div>
        </div>
    );
}
</file>

<file path="firebase-data/storage_export/metadata/962b3f69-c119-415e-9e0b-7214764838df.json">
{
  "name": "projects/1/stl/ボディ187_1770448719111.stl",
  "bucket": "demo-bom3d-sn923.appspot.com",
  "metageneration": 1,
  "generation": 1770448719129,
  "contentType": "application/octet-stream",
  "storageClass": "STANDARD",
  "contentDisposition": "inline",
  "downloadTokens": [
    "0d5b873f-5566-41c8-9aed-2966cb89c568"
  ],
  "etag": "/8CRwCb9eSxkxd1bg1VpEt1L/RM",
  "customMetadata": {},
  "timeCreated": "2026-02-07T07:18:39.129Z",
  "updated": "2026-02-07T07:18:39.129Z",
  "size": 39684,
  "md5Hash": "jZtKIN6hQiBgTaoJmooYZg==",
  "crc32c": "166781100"
}
</file>

<file path=".continue/agents/new-config.yaml">
# This is an example configuration file
# To learn more, see the full config.yaml reference: https://docs.continue.dev/reference

name: Example Config
version: 1.0.0
schema: v1

# Define which models can be used
# https://docs.continue.dev/customization/models
models:
  - name: my gpt-5
    provider: openai
    model: gpt-5
    apiKey: YOUR_OPENAI_API_KEY_HERE
  - uses: ollama/qwen2.5-coder-7b
  - uses: anthropic/claude-4-sonnet
    with:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}

# MCP Servers that Continue can access
# https://docs.continue.dev/customization/mcp-tools
mcpServers:
  - uses: anthropic/memory-mcp
</file>

<file path=".env,local">
# Firebase Project ID (Emulator用に 'demo-' を付ける)
NEXT_PUBLIC_FIREBASE_PROJECT_ID=demo-bom3d-sn923

# 各種エミュレータのポート番号（デフォルト）
NEXT_PUBLIC_FIREBASE_FIRESTORE_EMULATOR_HOST=localhost:8080
NEXT_PUBLIC_FIREBASE_AUTH_EMULATOR_HOST=http://localhost:9099
</file>

<file path=".gitignore">
# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local
.env

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
Thumbs.db
</file>

<file path="app/actions/importStl.ts">
'use server'

import { storage, db } from '@/lib/firebase';
import { ref, uploadBytes, getDownloadURL } from 'firebase/storage';
import {
    collection,
    getDocs,
    doc,
    setDoc,
    query,
    where,
    serverTimestamp
} from 'firebase/firestore';
import { revalidatePath } from 'next/cache';
import { parseFileName, ParsedFileInfo } from '@/lib/utils/parseFileName';
import { Part, PartItem, ProcessStatus } from '@/app/types';

export interface ImportResult {
    success: boolean;
    fileName: string;
    partNumber?: string;
    partId?: number;
    itemsCreated?: number;
    error?: string;
}

/**
 * 単一のSTLファイルをインポートする
 * 
 * @param file - アップロードするファイル（FormData経由）
 * @param projectId - プロジェクトID
 * @param defaultStatus - 初期ステータス（デフォルト: 'CUTTING'）
 * @returns インポート結果
 */
export async function importSingleStl(
    fileBuffer: ArrayBuffer,
    fileName: string,
    projectId: number,
    defaultStatus: ProcessStatus = 'CUTTING'
): Promise<ImportResult> {
    try {
        // 1. ファイル名を解析
        const parsed = parseFileName(fileName);

        if (!parsed.isValid) {
            return {
                success: false,
                fileName,
                error: parsed.errorMessage || 'ファイル名の解析に失敗しました'
            };
        }

        const { partNumber, quantity } = parsed;

        // 2. Firebase Storage にアップロード
        const timestamp = Date.now();
        const storagePath = `projects/${projectId}/stl/${partNumber}_${timestamp}.stl`;
        const storageRef = ref(storage, storagePath);

        await uploadBytes(storageRef, fileBuffer);
        const downloadUrl = await getDownloadURL(storageRef);

        // 3. Firestore で該当する part_number を検索
        const partsRef = collection(db, 'parts');
        const q = query(
            partsRef,
            where('part_number', '==', partNumber),
            where('project_id', '==', projectId)
        );
        const snapshot = await getDocs(q);

        let partId: number;

        if (snapshot.empty) {
            // 4a. 該当する Part がなければ新規作成
            const allPartsSnapshot = await getDocs(collection(db, 'parts'));
            const existingIds = allPartsSnapshot.docs.map(d => Number(d.id));
            partId = existingIds.length > 0 ? Math.max(...existingIds) + 1 : 1;

            const newPart: Part = {
                id: partId,
                part_number: partNumber,
                project_id: projectId
            };

            await setDoc(doc(db, 'parts', String(partId)), newPart);
            console.log(`Created new Part: ${partNumber} (ID: ${partId})`);
        } else {
            // 4b. 既存の Part を使用
            partId = Number(snapshot.docs[0].id);
            console.log(`Using existing Part: ${partNumber} (ID: ${partId})`);
        }

        // 5. 指定された個数分の PartItem を作成
        const allItemsSnapshot = await getDocs(collection(db, 'partItems'));
        const existingItemIds = allItemsSnapshot.docs.map(d => Number(d.id));
        let nextItemId = existingItemIds.length > 0 ? Math.max(...existingItemIds) + 1 : 1;

        for (let i = 0; i < quantity; i++) {
            const newItem: PartItem = {
                id: nextItemId,
                part_id: partId,
                storage_case: `AUTO-${partNumber}-${i + 1}`,
                status: defaultStatus,
                completed_at: null,
                updated_at: serverTimestamp()
            };

            await setDoc(doc(db, 'partItems', String(nextItemId)), newItem);
            nextItemId++;
        }

        console.log(`Created ${quantity} PartItems for Part ${partId}`);

        // 6. キャッシュを再検証
        revalidatePath('/');
        revalidatePath(`/project/${projectId}`);

        return {
            success: true,
            fileName,
            partNumber,
            partId,
            itemsCreated: quantity
        };

    } catch (error) {
        console.error('Error importing STL:', error);
        return {
            success: false,
            fileName,
            error: error instanceof Error ? error.message : '不明なエラーが発生しました'
        };
    }
}

/**
 * 複数のSTLファイルを一括インポートする
 * 
 * @param files - アップロードするファイルの配列
 * @param projectId - プロジェクトID
 * @param defaultStatus - 初期ステータス
 * @returns インポート結果の配列
 */
export async function importMultipleStl(
    filesData: Array<{ buffer: ArrayBuffer; name: string }>,
    projectId: number,
    defaultStatus: ProcessStatus = 'CUTTING'
): Promise<ImportResult[]> {
    const results: ImportResult[] = [];

    for (const fileData of filesData) {
        const result = await importSingleStl(
            fileData.buffer,
            fileData.name,
            projectId,
            defaultStatus
        );
        results.push(result);
    }

    return results;
}

/**
 * ファイル名のプレビュー解析（実際のインポートは行わない）
 * 
 * @param fileNames - ファイル名の配列
 * @returns 解析結果の配列
 */
export async function previewFileNames(fileNames: string[]): Promise<ParsedFileInfo[]> {
    return fileNames.map(parseFileName);
}
</file>

<file path="app/actions/updateItemStatus.ts">
'use server'

import { mockStore } from '@/lib/mockStore'
import { revalidatePath } from 'next/cache'

/**
 * 部品アイテムのステータスを更新するサーバーアクション
 * @param itemId - 部品アイテムのID
 * @param newStatus - 新しいステータス（工程）
 */
export async function updateItemStatus(itemId: string | number, newStatus: string) {
    try {
        await mockStore.updatePartItemStatus(itemId, newStatus);

        // キャッシュを更新してUIに反映
        revalidatePath('/');

        return { success: true };
    } catch (error) {
        console.error('Failed to update item status:', error);
        return { success: false, error: (error as Error).message };
    }
}
</file>

<file path="app/api/import-stl/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { importMultipleStl } from '@/app/actions/importStl';
import { ProcessStatus } from '@/app/types';

export async function POST(request: NextRequest) {
    try {
        const { projectId, defaultStatus, filesData } = await request.json();

        if (!projectId || !filesData || !Array.isArray(filesData)) {
            return NextResponse.json(
                { error: 'Invalid request parameters' },
                { status: 400 }
            );
        }

        // Uint8Array を ArrayBuffer に変換
        const convertedFilesData = filesData.map((fd: any) => ({
            name: fd.name,
            buffer: new Uint8Array(fd.buffer).buffer
        }));

        const results = await importMultipleStl(
            convertedFilesData,
            projectId,
            (defaultStatus as ProcessStatus) || 'CUTTING'
        );

        return NextResponse.json(results);
    } catch (error) {
        console.error('Error in import-stl API:', error);
        return NextResponse.json(
            { error: error instanceof Error ? error.message : 'Internal server error' },
            { status: 500 }
        );
    }
}
</file>

<file path="app/api/preview-filenames/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { parseFileNames } from '@/lib/utils/parseFileName';

export async function POST(request: NextRequest) {
    try {
        const { fileNames } = await request.json();

        if (!Array.isArray(fileNames)) {
            return NextResponse.json(
                { error: 'fileNames must be an array' },
                { status: 400 }
            );
        }

        const results = parseFileNames(fileNames);
        return NextResponse.json(results);
    } catch (error) {
        console.error('Error in preview-filenames API:', error);
        return NextResponse.json(
            { error: 'Internal server error' },
            { status: 500 }
        );
    }
}
</file>

<file path="app/components/CartModal.tsx">
'use client';

import React from 'react';

interface CartItem {
    id: number;
    part_number: string;
    count: number;
}

interface CartModalProps {
    isOpen: boolean;
    onClose: () => void;
    items: CartItem[];
    onDownload: () => void;
}

export function CartModal({ isOpen, onClose, items, onDownload }: CartModalProps) {
    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[100] p-4">
            <div className="bg-white rounded-2xl shadow-2xl w-full max-w-2xl overflow-hidden">
                <div className="p-6 border-b border-gray-100 flex justify-between items-center">
                    <h2 className="text-2xl font-bold text-gray-800">プリント用カート</h2>
                    <button onClick={onClose} className="text-gray-400 hover:text-gray-600">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>

                <div className="p-6 max-h-[60vh] overflow-y-auto">
                    {items.length === 0 ? (
                        <p className="text-center text-gray-500 py-8">カートに部品が入っていません。</p>
                    ) : (
                        <table className="w-full">
                            <thead className="text-xs text-gray-400 uppercase border-b">
                                <tr>
                                    <th className="text-left pb-2">部品番号</th>
                                    <th className="text-right pb-2">ダウンロード数量</th>
                                    <th className="text-right pb-2">ファイル名</th>
                                </tr>
                            </thead>
                            <tbody className="divide-y divide-gray-100">
                                {items.map((item) => (
                                    <tr key={item.id}>
                                        <td className="py-4 font-semibold text-gray-800">{item.part_number}</td>
                                        <td className="py-4 text-right">
                                            <input
                                                type="number"
                                                defaultValue={item.count}
                                                className="w-16 border rounded p-1 text-right"
                                            />
                                        </td>
                                        <td className="py-4 text-right text-sm text-gray-500 font-mono">
                                            {item.part_number}.stl
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    )}
                </div>

                <div className="p-6 bg-gray-50 flex gap-4">
                    <button
                        onClick={onClose}
                        className="flex-1 px-6 py-3 rounded-xl border border-gray-300 font-bold text-gray-600 hover:bg-white transition-colors"
                    >
                        戻る
                    </button>
                    <button
                        onClick={onDownload}
                        disabled={items.length === 0}
                        className="flex-1 px-6 py-3 rounded-xl bg-green-600 text-white font-bold hover:bg-green-700 transition-colors shadow-lg disabled:bg-gray-300"
                    >
                        Zipで一括ダウンロード
                    </button>
                </div>
            </div>
        </div>
    );
}
</file>

<file path="app/components/common/FileDownloadButton.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { ref, getDownloadURL } from 'firebase/storage';
import { storage } from '@/lib/firebase';

interface FileDownloadButtonProps {
    storagePath: string;
    fileName: string;
    label?: string;
    variant?: 'primary' | 'outline' | 'ghost';
    icon?: React.ReactNode;
}

export default function FileDownloadButton({
    storagePath,
    fileName,
    label,
    variant = 'outline',
    icon
}: FileDownloadButtonProps) {
    const [downloadUrl, setDownloadUrl] = useState<string | null>(null);
    const [isLoading, setIsLoading] = useState(true);
    const [isError, setIsError] = useState(false);

    useEffect(() => {
        const fetchUrl = async () => {
            setIsLoading(true);
            setIsError(false);
            try {
                const fileRef = ref(storage, storagePath);
                const url = await getDownloadURL(fileRef);
                setDownloadUrl(url);
            } catch (error: any) {
                console.error(`Error fetching download URL for ${storagePath}:`, error);
                if (error.code === 'storage/object-not-found') {
                    setIsError(true);
                } else {
                    setIsError(true);
                }
            } finally {
                setIsLoading(false);
            }
        };

        if (storagePath) {
            fetchUrl();
        }
    }, [storagePath]);

    const handleDownload = () => {
        if (!downloadUrl) return;

        // Use a hidden anchor tag to trigger download with fileName
        const link = document.createElement('a');
        link.href = downloadUrl;
        link.download = fileName;
        link.target = '_blank';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    };

    const baseStyles = "inline-flex items-center justify-center gap-2 px-3 py-1.5 rounded-md text-xs font-bold transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed";

    const variants = {
        primary: "bg-blue-600 text-white hover:bg-blue-700 shadow-sm",
        outline: "bg-white text-gray-700 border border-gray-300 hover:bg-gray-50",
        ghost: "bg-transparent text-gray-600 hover:bg-gray-100"
    };

    const defaultIcon = (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-3.5 w-3.5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
        </svg>
    );

    if (isLoading) {
        return (
            <button disabled className={`${baseStyles} ${variants[variant]}`}>
                <span className="animate-spin rounded-full h-3.5 w-3.5 border-b-2 border-current"></span>
                {label || 'Loading...'}
            </button>
        );
    }

    if (isError) {
        return (
            <button disabled title="ファイルが登録されていません" className={`${baseStyles} ${variants[variant]} opacity-40`}>
                {icon || defaultIcon}
                {label ? `${label} (未登録)` : '未登録'}
            </button>
        );
    }

    return (
        <button
            onClick={handleDownload}
            className={`${baseStyles} ${variants[variant]}`}
        >
            {icon || defaultIcon}
            {label}
        </button>
    );
}
</file>

<file path="app/components/StlImportModal.tsx">
'use client';

import React, { useState, useCallback } from 'react';
import { ParsedFileInfo } from '@/lib/utils/parseFileName';
import { ProcessStatus } from '@/app/types';

interface StlImportModalProps {
    isOpen: boolean;
    onClose: () => void;
    projectId: number;
    onImportComplete?: () => void;
}

interface FileWithPreview {
    file: File;
    parsed: ParsedFileInfo;
}

export function StlImportModal({ isOpen, onClose, projectId, onImportComplete }: StlImportModalProps) {
    const [files, setFiles] = useState<FileWithPreview[]>([]);
    const [isDragging, setIsDragging] = useState(false);
    const [isUploading, setIsUploading] = useState(false);
    const [uploadProgress, setUploadProgress] = useState<string>('');
    const [defaultStatus, setDefaultStatus] = useState<ProcessStatus>('CUTTING');

    // ファイル名を解析してプレビューリストに追加
    const handleFiles = useCallback(async (fileList: FileList | File[]) => {
        const stlFiles = Array.from(fileList).filter(
            file => file.name.toLowerCase().endsWith('.stl')
        );

        if (stlFiles.length === 0) {
            alert('STLファイルを選択してください');
            return;
        }

        // サーバーサイドの解析関数を呼び出す
        const fileNames = stlFiles.map(f => f.name);
        const response = await fetch('/api/preview-filenames', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ fileNames })
        });

        const parsedInfos: ParsedFileInfo[] = await response.json();

        const filesWithPreview: FileWithPreview[] = stlFiles.map((file, index) => ({
            file,
            parsed: parsedInfos[index]
        }));

        setFiles(prev => [...prev, ...filesWithPreview]);
    }, []);

    // ドラッグ&ドロップのハンドラー
    const handleDragEnter = useCallback((e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(true);
    }, []);

    const handleDragLeave = useCallback((e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
    }, []);

    const handleDragOver = useCallback((e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
    }, []);

    const handleDrop = useCallback((e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);

        const droppedFiles = e.dataTransfer.files;
        if (droppedFiles.length > 0) {
            handleFiles(droppedFiles);
        }
    }, [handleFiles]);

    // ファイル選択ダイアログ
    const handleFileSelect = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
        if (e.target.files && e.target.files.length > 0) {
            handleFiles(e.target.files);
        }
    }, [handleFiles]);

    // ファイルを削除
    const removeFile = useCallback((index: number) => {
        setFiles(prev => prev.filter((_, i) => i !== index));
    }, []);

    // インポート実行
    const handleImport = useCallback(async () => {
        if (files.length === 0) {
            alert('ファイルを選択してください');
            return;
        }

        // 無効なファイルがあるかチェック
        const invalidFiles = files.filter(f => !f.parsed.isValid);
        if (invalidFiles.length > 0) {
            const confirm = window.confirm(
                `${invalidFiles.length}件の無効なファイルがあります。有効なファイルのみインポートしますか?`
            );
            if (!confirm) return;
        }

        setIsUploading(true);
        setUploadProgress('アップロード中...');

        try {
            // ファイルをArrayBufferに変換
            const filesData = await Promise.all(
                files
                    .filter(f => f.parsed.isValid)
                    .map(async ({ file }) => ({
                        buffer: await file.arrayBuffer(),
                        name: file.name
                    }))
            );

            // サーバーアクションを呼び出す
            const response = await fetch('/api/import-stl', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    projectId,
                    defaultStatus,
                    filesData: filesData.map(fd => ({
                        name: fd.name,
                        buffer: Array.from(new Uint8Array(fd.buffer))
                    }))
                })
            });

            const results = await response.json();

            const successCount = results.filter((r: any) => r.success).length;
            const failCount = results.filter((r: any) => !r.success).length;

            setUploadProgress(`完了: ${successCount}件成功, ${failCount}件失敗`);

            setTimeout(() => {
                setFiles([]);
                setUploadProgress('');
                setIsUploading(false);
                onImportComplete?.();
                onClose();
            }, 2000);

        } catch (error) {
            console.error('Import error:', error);
            setUploadProgress('エラーが発生しました');
            setIsUploading(false);
        }
    }, [files, projectId, defaultStatus, onImportComplete, onClose]);

    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[100] p-4">
            <div className="bg-white rounded-2xl shadow-2xl w-full max-w-4xl overflow-hidden">
                {/* ヘッダー */}
                <div className="p-6 border-b border-gray-100 flex justify-between items-center bg-gradient-to-r from-blue-600 to-blue-700">
                    <h2 className="text-2xl font-bold text-white">STLファイルインポート</h2>
                    <button
                        onClick={onClose}
                        disabled={isUploading}
                        className="text-white/80 hover:text-white disabled:opacity-50"
                    >
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>

                {/* ドラッグ&ドロップエリア */}
                <div className="p-6">
                    <div
                        onDragEnter={handleDragEnter}
                        onDragLeave={handleDragLeave}
                        onDragOver={handleDragOver}
                        onDrop={handleDrop}
                        className={`border-2 border-dashed rounded-xl p-12 text-center transition-all ${isDragging
                                ? 'border-blue-500 bg-blue-50'
                                : 'border-gray-300 bg-gray-50 hover:border-blue-400 hover:bg-blue-50/50'
                            }`}
                    >
                        <svg
                            className="mx-auto h-16 w-16 text-gray-400 mb-4"
                            stroke="currentColor"
                            fill="none"
                            viewBox="0 0 48 48"
                            aria-hidden="true"
                        >
                            <path
                                d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02"
                                strokeWidth={2}
                                strokeLinecap="round"
                                strokeLinejoin="round"
                            />
                        </svg>
                        <p className="text-lg font-semibold text-gray-700 mb-2">
                            STLファイルをドラッグ&ドロップ
                        </p>
                        <p className="text-sm text-gray-500 mb-4">または</p>
                        <label className="inline-block px-6 py-3 bg-blue-600 text-white font-bold rounded-xl hover:bg-blue-700 transition-colors cursor-pointer shadow-lg">
                            ファイルを選択
                            <input
                                type="file"
                                multiple
                                accept=".stl"
                                onChange={handleFileSelect}
                                className="hidden"
                                disabled={isUploading}
                            />
                        </label>
                    </div>

                    {/* 初期ステータス選択 */}
                    <div className="mt-6 flex items-center gap-4">
                        <label className="font-semibold text-gray-700">初期ステータス:</label>
                        <select
                            value={defaultStatus}
                            onChange={(e) => setDefaultStatus(e.target.value as ProcessStatus)}
                            disabled={isUploading}
                            className="px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                        >
                            <option value="UNPRINTED">未プリント</option>
                            <option value="PRINTED">プリント済み</option>
                            <option value="SURFACE_TREATMENT">表面処理</option>
                            <option value="CUTTING">切削</option>
                            <option value="PAINTING">塗装</option>
                            <option value="READY">完成</option>
                        </select>
                    </div>
                </div>

                {/* プレビューリスト */}
                {files.length > 0 && (
                    <div className="px-6 pb-6">
                        <h3 className="text-lg font-bold text-gray-800 mb-4">
                            抽出された部品番号 ({files.length}件)
                        </h3>
                        <div className="max-h-[40vh] overflow-y-auto border border-gray-200 rounded-xl">
                            <table className="w-full">
                                <thead className="bg-gray-100 sticky top-0">
                                    <tr className="text-xs text-gray-600 uppercase">
                                        <th className="text-left p-3">ファイル名</th>
                                        <th className="text-left p-3">部品番号</th>
                                        <th className="text-center p-3">個数</th>
                                        <th className="text-left p-3">状態</th>
                                        <th className="text-center p-3">操作</th>
                                    </tr>
                                </thead>
                                <tbody className="divide-y divide-gray-100">
                                    {files.map((fileWithPreview, index) => (
                                        <tr key={index} className={fileWithPreview.parsed.isValid ? '' : 'bg-red-50'}>
                                            <td className="p-3 text-sm font-mono text-gray-700">
                                                {fileWithPreview.file.name}
                                            </td>
                                            <td className="p-3 font-semibold text-gray-800">
                                                {fileWithPreview.parsed.partNumber || '-'}
                                            </td>
                                            <td className="p-3 text-center font-bold text-blue-600">
                                                {fileWithPreview.parsed.quantity}
                                            </td>
                                            <td className="p-3">
                                                {fileWithPreview.parsed.isValid ? (
                                                    <span className="inline-flex items-center px-2 py-1 rounded-full text-xs font-semibold bg-green-100 text-green-800">
                                                        ✓ 有効
                                                    </span>
                                                ) : (
                                                    <span className="inline-flex items-center px-2 py-1 rounded-full text-xs font-semibold bg-red-100 text-red-800">
                                                        ✗ {fileWithPreview.parsed.errorMessage}
                                                    </span>
                                                )}
                                            </td>
                                            <td className="p-3 text-center">
                                                <button
                                                    onClick={() => removeFile(index)}
                                                    disabled={isUploading}
                                                    className="text-red-500 hover:text-red-700 disabled:opacity-50"
                                                >
                                                    削除
                                                </button>
                                            </td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    </div>
                )}

                {/* アップロード進捗 */}
                {uploadProgress && (
                    <div className="px-6 pb-4">
                        <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 text-center">
                            <p className="text-blue-800 font-semibold">{uploadProgress}</p>
                        </div>
                    </div>
                )}

                {/* フッター */}
                <div className="p-6 bg-gray-50 flex gap-4">
                    <button
                        onClick={onClose}
                        disabled={isUploading}
                        className="flex-1 px-6 py-3 rounded-xl border border-gray-300 font-bold text-gray-600 hover:bg-white transition-colors disabled:opacity-50"
                    >
                        キャンセル
                    </button>
                    <button
                        onClick={handleImport}
                        disabled={files.length === 0 || isUploading}
                        className="flex-1 px-6 py-3 rounded-xl bg-blue-600 text-white font-bold hover:bg-blue-700 transition-colors shadow-lg disabled:bg-gray-300 disabled:cursor-not-allowed"
                    >
                        {isUploading ? 'インポート中...' : `インポート実行 (${files.filter(f => f.parsed.isValid).length}件)`}
                    </button>
                </div>
            </div>
        </div>
    );
}
</file>

<file path="app/components/SummaryCard.tsx">
// app/dashboard/components/SummaryCard.tsx
import React from 'react';

interface SummaryCardProps {
  title: string;
  value: number | string;
  valueColor?: string;
}

export function SummaryCard({ title, value, valueColor = 'text-gray-800' }: SummaryCardProps) {
  return (
    <div className="bg-white p-6 rounded-xl shadow-lg flex items-center">
      <div>
        <p className="text-lg text-gray-500">{title}</p>
        <p className={`text-5xl font-extrabold ${valueColor}`}>{value}</p>
      </div>
    </div>
  );
}
</file>

<file path="docs/INTEGRATION_EXAMPLE.md">
# プロジェクトページへのSTLインポート機能統合例

## 統合方法

`app/project/[id]/page.tsx` を以下のように修正して、STLインポートボタンを追加します。

```tsx
import Link from 'next/link';
import { notFound } from 'next/navigation';
import { aggregateProgress } from '@/app/utils';
import { SummaryCard } from '@/app/components/SummaryCard';
import { mockStore } from '@/lib/mockStore';
import ProjectClientContent from './ProjectClientContent';
// ↓ 追加
import ProjectPageClient from './ProjectPageClient';

interface PageProps {
    params: Promise<{
        id: string;
    }>;
}

export default async function ProjectDetailPage(props: PageProps) {
    const params = await props.params;
    const projectId = parseInt(params.id);
    if (isNaN(projectId)) {
        notFound();
    }

    const project = await mockStore.getProject(projectId);
    if (!project) {
        notFound();
    }

    const parts = await mockStore.getParts(projectId);
    const partItems = await mockStore.getPartItems(projectId);

    const totalInventory = partItems.length;
    const inProgress = partItems.filter(item => item.status !== 'READY').length;

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const completedToday = partItems.filter(item =>
        item.completed_at && new Date(item.completed_at) >= today
    ).length;

    const progressData = aggregateProgress(parts, partItems);

    return (
        <ProjectPageClient
            project={project}
            projectId={projectId}
            totalInventory={totalInventory}
            inProgress={inProgress}
            completedToday={completedToday}
            progressData={progressData}
            parts={parts}
            partItems={partItems}
        />
    );
}
```

## 新しいクライアントコンポーネントの作成

`app/project/[id]/ProjectPageClient.tsx` を作成:

```tsx
'use client';

import Link from 'next/link';
import { useState } from 'react';
import { SummaryCard } from '@/app/components/SummaryCard';
import { StlImportModal } from '@/app/components/StlImportModal';
import ProjectClientContent from './ProjectClientContent';
import { Part, PartItem, Project } from '@/app/types';

interface ProjectPageClientProps {
    project: Project;
    projectId: number;
    totalInventory: number;
    inProgress: number;
    completedToday: number;
    progressData: any[];
    parts: Part[];
    partItems: PartItem[];
}

export default function ProjectPageClient({
    project,
    projectId,
    totalInventory,
    inProgress,
    completedToday,
    progressData,
    parts,
    partItems
}: ProjectPageClientProps) {
    const [isImportModalOpen, setIsImportModalOpen] = useState(false);

    const handleImportComplete = () => {
        // インポート完了後にページをリロード
        window.location.reload();
    };

    return (
        <div className="bg-gray-50 min-h-screen p-4 sm:p-6 lg:p-8 font-sans">
            <header className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-8 gap-4">
                <div>
                    <Link href="/" className="text-blue-600 hover:text-blue-800 mb-2 inline-block font-medium">
                        ← プロジェクト一覧へ戻る
                    </Link>
                    <h1 className="text-3xl font-bold text-gray-800">
                        {project.name}
                    </h1>
                    <p className="text-gray-600 mt-1">{project.description}</p>
                </div>
                <div className="flex gap-3">
                    {/* STLインポートボタン（新規追加） */}
                    <button
                        onClick={() => setIsImportModalOpen(true)}
                        className="bg-green-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-green-700 transition-all"
                    >
                        📁 STLインポート
                    </button>
                    
                    <Link href={`/print?project_id=${projectId}`}>
                        <span className="bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-blue-700 transition-all cursor-pointer inline-block">
                            3Dプリント登録
                        </span>
                    </Link>
                </div>
            </header>

            {/* サマリーカード */}
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
                <SummaryCard title="総在庫数" value={totalInventory} />
                <SummaryCard title="仕掛品数" value={inProgress} valueColor="text-orange-500" />
                <SummaryCard title="本日完了数" value={completedToday} valueColor="text-green-500" />
            </div>

            {/* インタラクティブな一覧・カート機能 */}
            <ProjectClientContent
                progressData={progressData}
                parts={parts}
                partItems={partItems}
                projectId={projectId}
            />

            {/* STLインポートモーダル */}
            <StlImportModal
                isOpen={isImportModalOpen}
                onClose={() => setIsImportModalOpen(false)}
                projectId={projectId}
                onImportComplete={handleImportComplete}
            />
        </div>
    );
}
```

## 変更点の説明

### 1. サーバーコンポーネントとクライアントコンポーネントの分離
- `page.tsx`: サーバーコンポーネント（データ取得のみ）
- `ProjectPageClient.tsx`: クライアントコンポーネント（UI + インタラクション）

### 2. STLインポートボタンの追加
- ヘッダー部分に緑色の「STLインポート」ボタンを追加
- クリックするとモーダルが開く

### 3. モーダルの統合
- `StlImportModal` コンポーネントをインポート
- `isImportModalOpen` ステートで表示/非表示を管理
- インポート完了後は `window.location.reload()` でページをリフレッシュ

## 使用フロー

1. ユーザーがプロジェクトページを開く
2. 「STLインポート」ボタンをクリック
3. モーダルが開き、ファイルをドラッグ&ドロップまたは選択
4. ファイル名が自動解析され、プレビュー表示
5. 初期ステータスを選択（デフォルト: CUTTING）
6. 「インポート実行」ボタンをクリック
7. Firebase Storage にアップロード + Firestore に保存
8. 完了後、ページが自動リロードされ、新しい部品が表示される

## より良い実装（オプション）

ページリロードの代わりに、SWRやReact Queryを使ってデータを再取得する方法もあります:

```tsx
import { useRouter } from 'next/navigation';

const router = useRouter();

const handleImportComplete = () => {
    // Next.jsのキャッシュを無効化してリフレッシュ
    router.refresh();
};
```

この方法なら、ページ全体をリロードせずにデータのみを再取得できます。
</file>

<file path="docs/STL_IMPORT_GUIDE.md">
# STLインポート機能 使用ガイド

## 概要

STLファイルのインポート機能により、ファイル名から部品番号と個数を自動解析し、Firebase Storageへのアップロードと同時にFirestoreに部品（Part）と工程アイテム（PartItem）を自動生成します。

## 実装されたファイル

### 1. ユーティリティ
- **`lib/utils/parseFileName.ts`**: ファイル名解析エンジン

### 2. サーバーアクション
- **`app/actions/importStl.ts`**: インポート処理のサーバーアクション

### 3. UIコンポーネント
- **`app/components/StlImportModal.tsx`**: ドラッグ&ドロップ対応のインポートモーダル

### 4. APIルート
- **`app/api/preview-filenames/route.ts`**: ファイル名プレビュー用API
- **`app/api/import-stl/route.ts`**: インポート実行用API

## ファイル名フォーマット

以下のフォーマットに対応しています:

| ファイル名 | 部品番号 | 個数 |
|-----------|---------|------|
| `PART123.stl` | PART123 | 1 |
| `PART123_x5.stl` | PART123 | 5 |
| `ABC-456_X10.stl` | ABC-456 | 10 |
| `ITEM_789_x3.stl` | ITEM_789 | 3 |

### ルール
- 拡張子は `.stl` または `.STL`
- 個数指定は `_x数字` または `_X数字` の形式
- 個数指定がない場合はデフォルトで1個
- 個数の範囲は 1〜1000

## 使用方法

### プロジェクトページに組み込む例

```tsx
'use client';

import { useState } from 'react';
import { StlImportModal } from '@/app/components/StlImportModal';

export default function ProjectPage({ projectId }: { projectId: number }) {
  const [isImportModalOpen, setIsImportModalOpen] = useState(false);

  const handleImportComplete = () => {
    // インポート完了後の処理（例: データ再取得）
    window.location.reload();
  };

  return (
    <div>
      {/* インポートボタン */}
      <button
        onClick={() => setIsImportModalOpen(true)}
        className="bg-green-600 text-white font-bold py-3 px-6 rounded-lg"
      >
        STLファイルをインポート
      </button>

      {/* インポートモーダル */}
      <StlImportModal
        isOpen={isImportModalOpen}
        onClose={() => setIsImportModalOpen(false)}
        projectId={projectId}
        onImportComplete={handleImportComplete}
      />
    </div>
  );
}
```

## 処理フロー

1. **ファイル選択/ドロップ**
   - ユーザーがSTLファイルを選択またはドラッグ&ドロップ
   - 複数ファイルの同時選択が可能

2. **プレビュー解析**
   - `/api/preview-filenames` を呼び出し
   - ファイル名から部品番号と個数を抽出
   - 解析結果をテーブル表示（有効/無効を色分け）

3. **初期ステータス選択**
   - ユーザーが初期ステータスを選択（デフォルト: CUTTING）
   - 選択肢: UNPRINTED, PRINTED, SURFACE_TREATMENT, CUTTING, PAINTING, READY

4. **インポート実行**
   - 「インポート実行」ボタンをクリック
   - `/api/import-stl` を呼び出し
   - 各ファイルに対して以下を実行:
     - Firebase Storageにアップロード（パス: `projects/{projectId}/stl/{partNumber}_{timestamp}.stl`）
     - Firestoreで部品番号を検索
     - 該当する部品がなければ新規作成
     - 指定個数分のPartItemを作成

5. **完了通知**
   - 成功/失敗件数を表示
   - `onImportComplete` コールバックを実行
   - モーダルを自動クローズ

## データ構造

### Part（部品）
```typescript
{
  id: number;
  part_number: string;  // ファイル名から抽出
  project_id: number;
}
```

### PartItem（工程アイテム）
```typescript
{
  id: number;
  part_id: number;
  storage_case: string;  // 自動生成: "AUTO-{partNumber}-{連番}"
  status: ProcessStatus;  // ユーザーが選択した初期ステータス
  completed_at: Date | null;
  updated_at: Timestamp;
}
```

## エラーハンドリング

- **無効なファイル名**: プレビュー時に赤色で表示、エラーメッセージを表示
- **アップロード失敗**: 個別にエラーを記録し、結果レポートに含める
- **重複部品番号**: 既存の部品を使用（新規作成しない）
- **ネットワークエラー**: エラーメッセージを表示し、リトライを促す

## カスタマイズ

### ファイル名パターンの拡張

`lib/utils/parseFileName.ts` の `parseFileName` 関数を編集:

```typescript
// 例: プレフィックス付きパターンに対応
const prefixPattern = /^PREFIX_(.+?)_x(\d+)$/;
```

### 初期ステータスの変更

`app/components/StlImportModal.tsx` の `defaultStatus` の初期値を変更:

```typescript
const [defaultStatus, setDefaultStatus] = useState<ProcessStatus>('PRINTED');
```

### ストレージパスのカスタマイズ

`app/actions/importStl.ts` の `storagePath` を変更:

```typescript
const storagePath = `custom/path/${partNumber}.stl`;
```

## テスト方法

1. Firebase Emulatorを起動
2. プロジェクトページを開く
3. 以下のテストファイルを準備:
   - `TEST001.stl`
   - `TEST002_x3.stl`
   - `INVALID_NAME.txt` (エラーテスト用)
4. ファイルをドラッグ&ドロップ
5. プレビューを確認
6. インポート実行
7. Firestore Emulator UIで確認:
   - `parts` コレクション
   - `partItems` コレクション
8. Storage Emulator UIでファイルを確認

## トラブルシューティング

### ファイルがアップロードされない
- Firebase Emulatorが起動しているか確認
- `lib/firebase.ts` の接続設定を確認
- ブラウザのコンソールでエラーを確認

### 部品が重複して作成される
- Firestoreのクエリが正しく動作しているか確認
- `part_number` と `project_id` の両方で検索していることを確認

### プレビューが表示されない
- `/api/preview-filenames` のレスポンスを確認
- ファイル名が `.stl` で終わっているか確認

## 今後の拡張案

- [ ] バッチインポートの進捗バー表示
- [ ] インポート履歴の記録
- [ ] ファイル名パターンのカスタム設定UI
- [ ] STLファイルのサムネイル生成
- [ ] 重複チェック時の上書き/スキップ選択
- [ ] CSVによる一括インポート
</file>

<file path="firebase-data/auth_export/accounts.json">
{"kind":"identitytoolkit#DownloadAccountResponse","users":[]}
</file>

<file path="firebase-data/auth_export/config.json">
{"signIn":{"allowDuplicateEmails":false},"emailPrivacyConfig":{"enableImprovedEmailPrivacy":false}}
</file>

<file path="firebase-data/firebase-export-metadata.json">
{
  "version": "15.5.1",
  "firestore": {
    "version": "1.20.2",
    "path": "firestore_export",
    "metadata_file": "firestore_export/firestore_export.overall_export_metadata"
  },
  "database": {
    "version": "4.11.2",
    "path": "database_export"
  },
  "auth": {
    "version": "15.5.1",
    "path": "auth_export"
  },
  "storage": {
    "version": "15.5.1",
    "path": "storage_export"
  }
}
</file>

<file path="firebase.json">
{
  "firestore": {
    "database": "(default)",
    "location": "nam5",
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  },
  "emulators": {
    "auth": {
      "port": 9099
    },
    "firestore": {
      "port": 8080
    },
    "database": {
      "port": 9000
    },
    "hosting": {
      "port": 5000
    },
    "storage": {
      "port": 9199
    },
    "ui": {
      "enabled": true
    },
    "singleProjectMode": true
  }
}
</file>

<file path="firestore.indexes.json">
{
  // Example (Standard Edition):
  //
  // "indexes": [
  //   {
  //     "collectionGroup": "widgets",
  //     "queryScope": "COLLECTION",
  //     "fields": [
  //       { "fieldPath": "foo", "arrayConfig": "CONTAINS" },
  //       { "fieldPath": "bar", "mode": "DESCENDING" }
  //     ]
  //   },
  //
  //  "fieldOverrides": [
  //    {
  //      "collectionGroup": "widgets",
  //      "fieldPath": "baz",
  //      "indexes": [
  //        { "order": "ASCENDING", "queryScope": "COLLECTION" }
  //      ]
  //    },
  //   ]
  // ]
  //
  // Example (Enterprise Edition):
  //
  // "indexes": [
  //   {
  //     "collectionGroup": "reviews",
  //     "queryScope": "COLLECTION_GROUP",
  //     "apiScope": "MONGODB_COMPATIBLE_API",
  //     "density": "DENSE",
  //     "multikey": false,
  //     "fields": [
  //       { "fieldPath": "baz", "mode": "ASCENDING" }
  //     ]
  //   },
  //   {
  //     "collectionGroup": "items",
  //     "queryScope": "COLLECTION_GROUP",
  //     "apiScope": "MONGODB_COMPATIBLE_API",
  //     "density": "SPARSE_ANY",
  //     "multikey": true,
  //     "fields": [
  //       { "fieldPath": "baz", "mode": "ASCENDING" }
  //     ]
  //   },
  // ]
  "indexes": [],
  "fieldOverrides": []
}
</file>

<file path="firestore.rules">
rules_version='2'

service cloud.firestore {
  match /databases/{database}/documents {
    match /{document=**} {
      // This rule allows anyone with your database reference to view, edit,
      // and delete all data in your database. It is useful for getting
      // started, but it is configured to expire after 30 days because it
      // leaves your app open to attackers. At that time, all client
      // requests to your database will be denied.
      //
      // Make sure to write security rules for your app before that time, or
      // else all client requests to your database will be denied until you
      // update your rules.
      allow read, write: if request.time < timestamp.date(2026, 3, 5);
    }
  }
}
</file>

<file path="lib/utils/parseFileName.ts">
/**
 * STLファイル名から部品情報を抽出するユーティリティ
 */

export interface ParsedFileInfo {
    /** 元のファイル名 */
    originalFileName: string;
    /** 抽出された部品番号 */
    partNumber: string;
    /** 個数（デフォルト: 1） */
    quantity: number;
    /** 解析が成功したか */
    isValid: boolean;
    /** エラーメッセージ（解析失敗時） */
    errorMessage?: string;
}

/**
 * ファイル名から部品番号と個数を抽出する
 * 
 * 対応フォーマット:
 * - PART123.stl → 部品番号: PART123, 個数: 1
 * - PART123_x5.stl → 部品番号: PART123, 個数: 5
 * - PART123_X10.stl → 部品番号: PART123, 個数: 10
 * - ABC-456_x3.stl → 部品番号: ABC-456, 個数: 3
 * 
 * @param fileName - 解析するファイル名（拡張子含む）
 * @returns 解析結果
 */
export function parseFileName(fileName: string): ParsedFileInfo {
    // 拡張子を除去
    const nameWithoutExt = fileName.replace(/\.(stl|STL)$/, '');

    if (!nameWithoutExt) {
        return {
            originalFileName: fileName,
            partNumber: '',
            quantity: 1,
            isValid: false,
            errorMessage: 'ファイル名が空です'
        };
    }

    // パターン1: 部品番号_x個数 または 部品番号_X個数
    const quantityPattern = /^(.+?)_[xX](\d+)$/;
    const match = nameWithoutExt.match(quantityPattern);

    if (match) {
        const partNumber = match[1].trim();
        const quantity = parseInt(match[2], 10);

        if (!partNumber) {
            return {
                originalFileName: fileName,
                partNumber: '',
                quantity: 1,
                isValid: false,
                errorMessage: '部品番号が空です'
            };
        }

        if (quantity <= 0 || quantity > 1000) {
            return {
                originalFileName: fileName,
                partNumber,
                quantity: 1,
                isValid: false,
                errorMessage: `個数が範囲外です（1-1000）: ${quantity}`
            };
        }

        return {
            originalFileName: fileName,
            partNumber,
            quantity,
            isValid: true
        };
    }

    // パターン2: 部品番号のみ（個数指定なし）
    const partNumber = nameWithoutExt.trim();

    if (!partNumber) {
        return {
            originalFileName: fileName,
            partNumber: '',
            quantity: 1,
            isValid: false,
            errorMessage: '部品番号が空です'
        };
    }

    return {
        originalFileName: fileName,
        partNumber,
        quantity: 1,
        isValid: true
    };
}

/**
 * 複数のファイル名を一括解析する
 * 
 * @param fileNames - ファイル名の配列
 * @returns 解析結果の配列
 */
export function parseFileNames(fileNames: string[]): ParsedFileInfo[] {
    return fileNames.map(parseFileName);
}

/**
 * 解析結果から有効なもののみをフィルタリング
 * 
 * @param parsedInfos - 解析結果の配列
 * @returns 有効な解析結果のみの配列
 */
export function filterValidParsedInfos(parsedInfos: ParsedFileInfo[]): ParsedFileInfo[] {
    return parsedInfos.filter(info => info.isValid);
}
</file>

<file path="next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
}

module.exports = nextConfig
</file>

<file path="postcss.config.js">
module.exports = {
  plugins: {
    '@tailwindcss/postcss': {},
  },
}
</file>

<file path="README.md">
# SN-923
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.{js,ts,jsx,tsx,mdx}',
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path=".firebaserc">
{
  "projects": {
    "default": "demo-bom3d-sn923"
  }
}
</file>

<file path="app/actions/reportDefect.ts">
'use server'

import { mockStore } from '@/lib/mockStore'
import { revalidatePath } from 'next/cache'

/**
 * 不良を報告し、再製作ジョブを生成するサーバーアクション
 * @param itemId - 不良が発生したアイテムのID
 * @param reason - 不良の理由
 */
export async function reportDefect(itemId: number | string, reason: string) {
    const id = typeof itemId === 'string' ? parseInt(itemId, 10) : itemId;

    const item = await mockStore.getPartItem(id);
    if (!item) {
        console.error(`Item ${id} not found`);
        return;
    }

    // 1. 現状のアイテムを「不良(DEFECTIVE)」にする
    await mockStore.updatePartItem(id, {
        status: 'DEFECTIVE'
    });

    // 2. 新しいジョブ（再製作）を生成する
    // 元のアイテムの情報を引き継ぎつつ、工程を「未プリント」に戻す
    await mockStore.addPartItem({
        part_id: item.part_id,
        storage_case: `${item.storage_case} (RE)`, // 再製作であることを示す
        status: 'UNPRINTED',
        completed_at: null
    });

    console.log(`Reported defect for item ${id}: ${reason}`);

    // キャッシュを更新
    revalidatePath('/');
    revalidatePath(`/item/${id}`);
    revalidatePath(`/project/${item.parts.project_id}`);
}
</file>

<file path="app/components/ModelViewer.tsx">
'use client';

import { Canvas, useLoader } from '@react-three/fiber';
import { OrbitControls, Stage } from '@react-three/drei';
import { useState, useEffect, Suspense } from 'react';
import { STLLoader } from 'three-stdlib';

function STLModel({ url }: { url: string }) {
    if (!url) return null;

    const geom = useLoader(STLLoader, url);

    return (
        /* rotation: [x, y, z] 
           Math.PI / 2 は 90度です。
           CADのZ上をThree.jsのY上に合わせるため、X軸を軸にマイナス90度回転させます。
        */
        <mesh
            geometry={geom}
            rotation={[-Math.PI / 2, 0, 0]}
        >
            <meshStandardMaterial color="#3b82f6" />
        </mesh>
    );
}

export function ModelViewer({ url }: { url: string }) {
    const [mounted, setMounted] = useState(false);

    useEffect(() => {
        setMounted(true);
    }, []);

    if (!mounted) {
        return <div className="w-full h-[400px] bg-gray-900 rounded-lg" />;
    }

    return (
        <div className="w-full h-[400px] bg-gray-900 rounded-lg">
            <Canvas shadows camera={{ position: [0, 0, 20], fov: 50 }}>
                <Suspense fallback={null}>
                    <Stage environment="city" intensity={0.5}>
                        <STLModel url={url} />
                    </Stage>
                </Suspense>
                <OrbitControls autoRotate />
            </Canvas>
        </div>
    );
}
</file>

<file path="app/constants.ts">
import { ProcessStatus } from './types';

export const PROCESSES: { key: ProcessStatus; name: string }[] = [
  { key: 'UNPRINTED', name: '未プリント' },
  { key: 'PRINTED', name: 'プリント済' },
  { key: 'CUTTING', name: '切削' },
  { key: 'SURFACE_TREATMENT', name: '表面処理' },
  { key: 'PAINTING', name: '塗装' },
  { key: 'ASSEMBLED', name: '組付け済み' },
];
</file>

<file path="app/globals.css">
@import "tailwindcss";
</file>

<file path="app/layout.tsx">
import './globals.css'
import type { Metadata } from "next"

export const metadata: Metadata = {
  title: "SN-923",
  description: "在庫管理アプリケーション",
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="ja">
      <body>{children}</body>
    </html>
  )
}
</file>

<file path="firebase-data/storage_export/buckets.json">
{
  "buckets": [
    {
      "id": "demo-no-project.appspot.com"
    },
    {
      "id": "demo-bom3d-sn923.appspot.com"
    }
  ]
}
</file>

<file path="scripts/seed-emulator.ts">
import { db } from '../lib/firebase';
import { projects, parts, partItems } from '../app/data';
import { collection, doc, setDoc, serverTimestamp } from 'firebase/firestore';

// @ts-ignore
process.env.NODE_ENV = 'development';

async function seed() {
    console.log('Seeding Firestore Emulator...');
    console.log('Connecting to Firestore (ensure Emulator is running on localhost:8080)...');

    // Projects
    console.log('Seeding Projects...');
    for (const project of projects) {
        const projectRef = doc(db, 'projects', String(project.id));
        await setDoc(projectRef, {
            ...project,
            // Ensure dates are compatible if strings
        });
    }

    // Parts
    console.log('Seeding Parts...');
    for (const part of parts) {
        const partRef = doc(db, 'parts', String(part.id));
        await setDoc(partRef, part);
    }

    // PartItems
    console.log('Seeding PartItems...');
    for (const item of partItems) {
        const itemRef = doc(db, 'partItems', String(item.id));
        await setDoc(itemRef, {
            ...item,
            // Convert Date object to Timestamp or keep as Date
            completed_at: item.completed_at ? item.completed_at : null,
            updated_at: serverTimestamp()
        });
    }

    console.log('Seeding completed!');
    process.exit(0);
}

seed().catch((error) => {
    console.error('Seeding failed:', error);
    process.exit(1);
});
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es2017",
    "useDefineForClassFields": true,
    "lib": [
      "es2020",
      "dom",
      "dom.iterable"
    ],
    "module": "esnext",
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
    /* Next.js */
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "incremental": true,
    /* Path mapping */
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "allowJs": true,
    "strict": false,
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}
</file>

<file path="app/components/PreviewModal.tsx">
'use client'

import { useState, useTransition } from 'react'
import { ModelViewer } from './ModelViewer'
import { PROCESSES } from '@/app/constants'
import { updateProcess } from '@/app/actions/updateProcess'
import { reportDefect } from '@/app/actions/reportDefect'

interface PreviewModalProps {
    isOpen: boolean
    onClose: () => void
    partNumber: string
    itemId?: number
    status?: string
    projectId?: number
}

export function PreviewModal({
    isOpen,
    onClose,
    partNumber,
    itemId,
    status,
    projectId
}: PreviewModalProps) {
    const [isPending, startTransition] = useTransition()
    const [defectReason, setDefectReason] = useState('')

    if (!isOpen) return null

    // 現在の工程より「前」の工程を抽出（差し戻し用）
    const currentIndex = PROCESSES.findIndex(p => p.key === status)
    const previousProcesses = PROCESSES.slice(0, currentIndex)

    const handleUpdateStatus = (statusKey: string) => {
        if (!itemId || !projectId) return
        startTransition(async () => {
            await updateProcess(itemId, statusKey, projectId)
            onClose()
        })
    }

    const handleReportDefect = () => {
        if (!itemId || !defectReason) return
        startTransition(async () => {
            await reportDefect(itemId, defectReason)
            setDefectReason('')
            onClose()
        })
    }

    return (
        <div className="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-[110] p-4">
            <div className="bg-white rounded-3xl w-full max-w-5xl max-h-[90vh] overflow-hidden flex flex-col shadow-2xl">

                {/* ヘッダー */}
                <div className="p-6 border-b flex justify-between items-center bg-gray-50">
                    <div>
                        <h3 className="text-2xl font-black text-gray-900">{partNumber}</h3>
                        <p className="text-sm text-gray-500 font-bold">ITEM ID: {itemId} / CURRENT: {status}</p>
                    </div>
                    <button
                        onClick={onClose}
                        className="w-10 h-10 flex items-center justify-center rounded-full hover:bg-gray-200 transition-colors text-2xl font-bold"
                    >
                        &times;
                    </button>
                </div>

                <div className="flex-1 flex flex-col md:flex-row overflow-hidden">
                    {/* 左側：3Dプレビュー */}
                    <div className="flex-[2] bg-gray-100 relative min-h-[300px]">
                        <ModelViewer url={`/models/${partNumber}.stl`} />
                        <div className="absolute bottom-4 left-4 bg-white/80 px-3 py-1 rounded text-xs font-bold text-gray-500">
                            3D PREVIEW MODE
                        </div>
                    </div>

                    {/* 右側：操作パネル */}
                    <div className="flex-1 border-l bg-white p-6 overflow-y-auto space-y-8">

                        {/* 1. 工程の差し戻し */}
                        <section>
                            <h4 className="text-sm font-black text-gray-400 uppercase tracking-widest mb-4">工程を差し戻す (手戻り)</h4>
                            <div className="grid grid-cols-1 gap-2">
                                {previousProcesses.length > 0 ? (
                                    previousProcesses.map((proc) => (
                                        <button
                                            key={proc.key}
                                            onClick={() => handleUpdateStatus(proc.key)}
                                            disabled={isPending}
                                            className="text-left px-4 py-3 border-2 border-orange-100 rounded-xl hover:border-orange-500 hover:bg-orange-50 transition-all group"
                                        >
                                            <span className="text-xs font-bold text-orange-400 block uppercase">{proc.key}へ戻す</span>
                                            <span className="font-bold text-gray-700 group-hover:text-orange-700">{proc.name}</span>
                                        </button>
                                    ))
                                ) : (
                                    <p className="text-sm text-gray-400 italic">差し戻せる前の工程はありません</p>
                                )}
                            </div>
                        </section>

                        <hr className="border-gray-100" />

                        {/* 2. 不良報告 */}
                        <section className="p-5 border-2 border-red-100 rounded-2xl bg-red-50/30">
                            <h4 className="text-lg font-black text-red-700 mb-2">不良を報告する</h4>
                            <p className="text-xs text-red-600 mb-4 leading-relaxed font-medium">
                                個体に欠陥がある場合、不良として確定させます。実行すると自動的に再製作ジョブが生成されます。
                            </p>
                            <div className="space-y-3">
                                <textarea
                                    value={defectReason}
                                    onChange={(e) => setDefectReason(e.target.value)}
                                    placeholder="不良の理由を入力してください..."
                                    className="w-full p-3 border-2 border-red-100 rounded-xl text-sm focus:border-red-500 outline-none resize-none h-24 font-medium"
                                />
                                <button
                                    onClick={handleReportDefect}
                                    disabled={isPending || !defectReason}
                                    className={`w-full py-4 rounded-xl font-black transition-all shadow-md ${isPending || !defectReason
                                        ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                                        : 'bg-red-600 text-white hover:bg-red-700 active:scale-95'
                                        }`}
                                >
                                    {isPending ? '処理中...' : '不良確定 & 再製作依頼'}
                                </button>
                            </div>
                        </section>

                    </div>
                </div>
            </div>
        </div>
    )
}
</file>

<file path="app/utils.ts">
// app/utils.ts
import { Part, PartItem, ProgressData, ProcessStatus } from './types';
import { PROCESSES } from './constants';

export const aggregateProgress = (parts: Part[], partItems: PartItem[]): any[] => {
  return parts.map(part => {
    const items = partItems.filter(item => item.part_id === part.id);

    // この部品の中で最も「進んでいない」工程を現在の工程とする
    // (全て完了していれば READY となる)
    const processOrder = PROCESSES.map(p => p.key);
    const currentProcess = items.length > 0
      ? items.reduce((earliest, item) => {
        return processOrder.indexOf(item.status) < processOrder.indexOf(earliest)
          ? item.status
          : earliest;
      }, 'READY' as ProcessStatus)
      : 'UNPRINTED';

    return {
      id: part.id,
      part_number: part.part_number,
      status: currentProcess, // Rename field
      storage_cases: Array.from(new Set(items.map(i => i.storage_case))),
      count: items.length
    };
  });
};
</file>

<file path="lib/firebase.ts">
import { initializeApp, getApps } from "firebase/app";
import { getFirestore, connectFirestoreEmulator } from "firebase/firestore";
import { getAuth, connectAuthEmulator } from "firebase/auth";
import { getStorage, connectStorageEmulator } from "firebase/storage";

const projectId = process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID || "demo-bom3d-sn923";

const firebaseConfig = {
    apiKey: "fake-api-key", // Emulator用ダミー
    authDomain: `${projectId}.firebaseapp.com`,
    projectId: projectId,
    storageBucket: `${projectId}.appspot.com`,
    messagingSenderId: "123456789",
    appId: "1:123456789:web:abcdef"
};

const app = getApps().length === 0 ? initializeApp(firebaseConfig) : getApps()[0];
const db = getFirestore(app);
const auth = getAuth(app);
const storage = getStorage(app);

const isEmulator = process.env.NODE_ENV === 'development' || projectId.startsWith('demo-');

if (isEmulator) {
    const g = global as any;
    if (!g._firebase_emulators_connected) {
        // 環境変数からポートを取得、なければデフォルト
        // localhost よりも 127.0.0.1 のほうが安定するケースがあるため変更
        connectFirestoreEmulator(db, '127.0.0.1', 8080);
        connectAuthEmulator(auth, "http://127.0.0.1:9099");
        connectStorageEmulator(storage, '127.0.0.1', 9199);
        g._firebase_emulators_connected = true;
        console.log(`Connected to Firebase Emulators: ${projectId}`);
    }
}

export { db, auth, storage };
</file>

<file path="app/actions/consumeItem.ts">
'use server'

import { mockStore } from '@/lib/mockStore'
import { revalidatePath } from 'next/cache'

/**
 * 部品アイテムを消費済みにするサーバーアクション
 * @param itemId - 消費する部品アイテムのID
 */
export async function consumeItem(itemId: string | number) {
  const id = typeof itemId === 'string' ? parseInt(itemId, 10) : itemId;

  await mockStore.updatePartItem(id, {
    status: 'READY', // 本来のロジックに合わせてREADYにするか、または別のステータス
    completed_at: new Date(),
    storage_case: 'CONSUMED' // 便宜上の表記
  });

  console.log(`Consumed item ${id}`);

  revalidatePath('/');
  revalidatePath(`/item/${id}`);
}
</file>

<file path="app/data.ts">
// app/data.ts
import { Part, PartItem, Project } from './types';

export const projects: Project[] = [
  { id: 1, name: '次世代ドローン開発', description: '高解像度カメラ搭載の新型ドローン開発プロジェクト', deadline: '2026-06-30' },
  { id: 2, name: '搬送ロボット製作', description: '倉庫内自動配送を行う自律走行ロボットの試作', deadline: '2026-04-15' }
];

export const parts: Part[] = [
  { id: 1, part_number: 'DRONE-ARM-01', project_id: 1 },
  { id: 2, part_number: 'DRONE-BODY-01', project_id: 1 },
  { id: 3, part_number: 'DRONE-PROP-01', project_id: 1 },
  { id: 4, part_number: 'ROBO-WHEEL-X', project_id: 2 }
];

export const partItems: PartItem[] = [
  // DRONE-ARM-01 (id: 1) - 分散配置
  { id: 101, part_id: 1, storage_case: 'Case-A1', status: 'UNPRINTED', completed_at: null },
  { id: 102, part_id: 1, storage_case: 'Case-A1', status: 'PRINTED', completed_at: null },
  { id: 103, part_id: 1, storage_case: 'Case-A2', status: 'PRINTED', completed_at: null },
  { id: 104, part_id: 1, storage_case: 'Case-A3', status: 'SURFACE_TREATMENT', completed_at: null },
  { id: 105, part_id: 1, storage_case: 'Case-A4', status: 'ASSEMBLED', completed_at: new Date() },

  // DRONE-BODY-01 (id: 2) - 特定工程に集中
  { id: 201, part_id: 2, storage_case: 'Case-B1', status: 'SURFACE_TREATMENT', completed_at: null },
  { id: 202, part_id: 2, storage_case: 'Case-B1', status: 'SURFACE_TREATMENT', completed_at: null },
  { id: 203, part_id: 2, storage_case: 'Case-B2', status: 'PAINTING', completed_at: null },

  // DRONE-PROP-01 (id: 3) - 少ないアイテム、不良あり
  { id: 301, part_id: 3, storage_case: 'Case-C1', status: 'UNPRINTED', completed_at: null },
  { id: 302, part_id: 3, storage_case: 'Case-C2', status: 'DEFECTIVE', completed_at: null },

  // ROBO-WHEEL-X (id: 4) - 別プロジェクト
  { id: 401, part_id: 4, storage_case: 'Case-R1', status: 'ASSEMBLED', completed_at: new Date(new Date().setDate(new Date().getDate() - 2)) }
];
</file>

<file path="app/types.ts">
export type ProcessStatus =
  | 'UNPRINTED'
  | 'PRINTED'
  | 'CUTTING'
  | 'SURFACE_TREATMENT'
  | 'PAINTING'
  | 'ASSEMBLED'
  | 'DEFECTIVE';

export interface Project {
  id: number;
  name: string;
  description: string;
  deadline: string;
}

export interface Part {
  id: number;
  part_number: string;
  project_id: number;
}

export interface PartItem {
  id: number;
  part_id: number;
  storage_case: string;
  status: ProcessStatus;
  completed_at: Date | null;
  updated_at?: any;
}

export interface ProgressData {
  part_number: string;
  storage_cases: string[];
  counts: Record<ProcessStatus, number>;
}
</file>

<file path="lib/mockStore.ts">
import { Part, PartItem, Project, ProcessStatus } from '@/app/types';
import { db } from './firebase';
import {
    collection,
    getDocs,
    doc,
    getDoc,
    updateDoc,
    setDoc,
    query,
    where,
    Timestamp,
    serverTimestamp
} from 'firebase/firestore';

// Firestoreのデータコンバーター（Date型の復元など）
const dateConverter = (data: any): any => {
    if (!data) return data;
    const result = { ...data };
    // completed_atなどのTimestampをDateに戻す
    Object.keys(result).forEach(key => {
        if (result[key] instanceof Timestamp) {
            result[key] = result[key].toDate();
        }
    });
    return result;
};

export const mockStore = {
    getProjects: async (): Promise<Project[]> => {
        const snapshot = await getDocs(collection(db, 'projects'));
        return snapshot.docs.map(doc => ({
            id: Number(doc.id),
            ...dateConverter(doc.data())
        })) as Project[];
    },

    getProject: async (id: number): Promise<Project | null> => {
        const docRef = doc(db, 'projects', String(id));
        const span = await getDoc(docRef);
        if (!span.exists()) return null;
        return { id: Number(span.id), ...dateConverter(span.data()) } as Project;
    },

    getParts: async (projectId?: number): Promise<Part[]> => {
        let q;
        if (projectId) {
            q = query(collection(db, 'parts'), where('project_id', '==', projectId));
        } else {
            q = collection(db, 'parts');
        }
        const snapshot = await getDocs(q);
        return snapshot.docs.map(doc => ({
            id: Number(doc.id),
            ...dateConverter(doc.data())
        })) as Part[];
    },

    getPartItems: async (projectId?: number): Promise<PartItem[]> => {
        // プロジェクトID指定がある場合、まず対象のPartを取得
        let targetPartIds: number[] | null = null;
        if (projectId) {
            const parts = await mockStore.getParts(projectId);
            targetPartIds = parts.map(p => p.id);
            if (targetPartIds.length === 0) return [];
        }

        // Firestoreの 'in' 句は最大10個までなので、ここでは全件取得してJSでフィルタリングする方式を採用
        // (プロトタイプのため簡易実装)
        const snapshot = await getDocs(collection(db, 'partItems'));
        const items = snapshot.docs.map(doc => ({
            id: Number(doc.id),
            ...dateConverter(doc.data())
        })) as PartItem[];

        if (targetPartIds) {
            return items.filter(item => targetPartIds!.includes(item.part_id));
        }
        return items;
    },

    getPartItem: async (id: number): Promise<(PartItem & { parts: Part }) | null> => {
        const itemRef = doc(db, 'partItems', String(id));
        const itemSnap = await getDoc(itemRef);

        if (!itemSnap.exists()) return null;
        const itemData = { id: Number(itemSnap.id), ...dateConverter(itemSnap.data()) } as PartItem;

        // 関連するPartを取得
        const partRef = doc(db, 'parts', String(itemData.part_id));
        const partSnap = await getDoc(partRef);

        if (!partSnap.exists()) {
            throw new Error(`Part not found for item ${id}`);
        }
        const partData = { id: Number(partSnap.id), ...dateConverter(partSnap.data()) } as Part;

        return { ...itemData, parts: partData };
    },

    updatePartItem: async (id: number, updates: Partial<PartItem>): Promise<void> => {
        const docRef = doc(db, 'partItems', String(id));
        await updateDoc(docRef, updates);
    },

    updatePartItemStatus: async (id: string | number, newStatus: string): Promise<void> => {
        const docRef = doc(db, 'partItems', String(id));
        await updateDoc(docRef, {
            status: newStatus as ProcessStatus,
            updated_at: serverTimestamp()
        });
    },

    addPartItem: async (item: Omit<PartItem, 'id'>): Promise<PartItem> => {
        // IDの自動採番（Max + 1）
        const snapshot = await getDocs(collection(db, 'partItems'));
        const ids = snapshot.docs.map(d => Number(d.id));
        const newId = ids.length > 0 ? Math.max(...ids) + 1 : 1;

        const newItem = { ...item, id: newId };
        const docRef = doc(db, 'partItems', String(newId));
        await setDoc(docRef, newItem);

        return newItem as PartItem;
    },

    // 互換性のためのダミーメソッド
    saveToLocalStorage: () => {
        console.warn('saveToLocalStorage is deprecated in Firestore mode');
    },

    loadFromLocalStorage: () => {
        console.warn('loadFromLocalStorage is deprecated in Firestore mode');
    }
};
</file>

<file path="app/actions/createPrinted.ts">
'use server'

import { storage, db } from '@/lib/firebase';
import { ref, uploadBytes, getDownloadURL } from 'firebase/storage';
import {
  collection,
  getDocs,
  doc,
  runTransaction,
  query,
  where,
  serverTimestamp,
  increment
} from 'firebase/firestore';
import { revalidatePath } from 'next/cache';
import { parseFileName } from '@/lib/utils/parseFileName';
import { Part, PartItem, ProcessStatus } from '@/app/types';

/**
 * 3Dプリントされた新しい部品アイテムを作成するサーバーアクション（強化版）
 * 
 * @param fileBuffer - STLファイルのArrayBuffer
 * @param fileName - ファイル名
 * @param projectId - プロジェクトID
 * @param qty - 数量
 * @param targetStatus - 初期ステータス
 */
export async function createPrinted(
  fileBuffer: ArrayBuffer,
  fileName: string,
  projectId: number,
  qty: number,
  targetStatus: ProcessStatus = 'PRINTED'
) {
  try {
    // 1. ファイル名を解析して部品番号を取得
    const parsed = parseFileName(fileName);
    if (!parsed.isValid) {
      throw new Error(parsed.errorMessage || 'ファイル名の解析に失敗しました');
    }
    const partNumber = parsed.partNumber;

    // 2. Firebase Storage にファイルを保存
    const timestamp = Date.now();
    const storagePath = `projects/${projectId}/stl/${partNumber}_${timestamp}.stl`;
    const storageRef = ref(storage, storagePath);
    await uploadBytes(storageRef, fileBuffer);
    const downloadUrl = await getDownloadURL(storageRef);

    // 3. Firestore トランザクションで部品とアイテムを作成
    await runTransaction(db, async (transaction) => {
      // 3a. 部品(Part)の存在確認
      const partsRef = collection(db, 'parts');
      const q = query(
        partsRef,
        where('part_number', '==', partNumber),
        where('project_id', '==', projectId)
      );
      const partQuerySnapshot = await getDocs(q); // トランザクション内での getDocs は制限がある場合があるが、Firebase V9+ では transaction.get(query) が基本。

      // 注意: Firestore トランザクション内でのクエリは複雑なため、
      // ここではドキュメントIDとして部品番号を使用するか、一度検索した後にトランザクションを実行するのが一般的。
      // しかし、要件に合わせて「整合性を保つ」ためにトランザクションを使用。

      let partId: number;

      if (partQuerySnapshot.empty) {
        // 新規作成が必要な場合、新しいIDを決定（ここでは簡易的に全件取得で最大ID+1）
        // 本来はカウンター用ドキュメントを使用するのが望ましい
        const allPartsSnapshot = await getDocs(collection(db, 'parts'));
        const existingIds = allPartsSnapshot.docs.map(d => Number(d.id));
        partId = existingIds.length > 0 ? Math.max(...existingIds) + 1 : 1;

        const newPart: Part = {
          id: partId,
          part_number: partNumber,
          project_id: projectId
        };

        const partDocRef = doc(db, 'parts', String(partId));
        transaction.set(partDocRef, newPart);
        console.log(`Transaction: Created new Part: ${partNumber} (ID: ${partId})`);
      } else {
        partId = Number(partQuerySnapshot.docs[0].id);
        console.log(`Transaction: Using existing Part: ${partNumber} (ID: ${partId})`);
      }

      // 3b. PartItem を指定された個数分作成
      const allItemsSnapshot = await getDocs(collection(db, 'partItems'));
      const existingItemIds = allItemsSnapshot.docs.map(d => Number(d.id));
      let nextItemId = existingItemIds.length > 0 ? Math.max(...existingItemIds) + 1 : 1;

      for (let i = 0; i < qty; i++) {
        const newItem: PartItem = {
          id: nextItemId,
          part_id: partId,
          storage_case: `AUTO-${partNumber}-${i + 1}`,
          status: targetStatus,
          completed_at: null,
          updated_at: serverTimestamp()
        };

        const itemDocRef = doc(db, 'partItems', String(nextItemId));
        transaction.set(itemDocRef, {
          ...newItem,
          stl_url: downloadUrl // 保存されたURLを紐付け
        });
        nextItemId++;
      }
    });

    console.log(`Successfully created ${qty} items for part ${partNumber}`);
    revalidatePath('/');
    if (projectId) revalidatePath(`/project/${projectId}`);

    return { success: true, partNumber };

  } catch (error) {
    console.error('Error in createPrinted:', error);
    throw error;
  }
}
</file>

<file path="app/actions/updateProcess.ts">
'use server'

import { mockStore } from '@/lib/mockStore'
import { ProcessStatus } from '@/app/types'
import { revalidatePath } from 'next/cache'

/**
 * 部品アイテムの工程を更新するサーバーアクション
 * @param itemId - 更新する部品アイテムのID
 * @param nextProcess - 次の工程名
 */
export async function updateProcess(
  itemId: string | number,
  nextProcess: string,
  projectId?: number
) {
  // 文字列IDを数値に変換（mockStoreの仕様に合わせる）
  const id = typeof itemId === 'string' ? parseInt(itemId, 10) : itemId;

  // メモリ上のデータを更新
  await mockStore.updatePartItem(id, {
    status: nextProcess as ProcessStatus,
    // READYに移行した場合は完了日時を設定
    completed_at: nextProcess === 'READY' ? new Date() : null
  });

  // 工程ログはモック版では省略、または必要なら追加
  console.log(`Updated item ${id} to status ${nextProcess}`);

  // キャッシュを更新してUIに反映
  revalidatePath('/');
  revalidatePath(`/item/${id}`);
  if (projectId) {
    revalidatePath(`/project/${projectId}`);
  }
}
</file>

<file path="app/page.tsx">
import Link from 'next/link';
import { mockStore } from '@/lib/mockStore';

/**
 * プロジェクト一覧ダッシュボード
 */
export default async function ProjectsDashboardPage() {
  const projects = await mockStore.getProjects();

  return (
    <div className="bg-gray-50 min-h-screen p-4 sm:p-6 lg:p-8 font-sans">
      <header className="mb-12 text-center">
        <h1 className="text-4xl font-extrabold text-gray-900 mb-4 tracking-tight">
          BOM進捗管理システム
        </h1>
        <p className="text-xl text-gray-600 max-w-2xl mx-auto">
          プロジェクトを選択して、部品の製造工程と進捗状況をリアルタイムで確認できます。
        </p>
      </header>

      <div className="max-w-6xl mx-auto grid grid-cols-1 md:grid-cols-2 gap-8">
        {projects.map((project) => (
          <Link key={project.id} href={`/project/${project.id}`}>
            <div className="group bg-white rounded-2xl shadow-sm hover:shadow-xl transition-all duration-300 border border-gray-100 overflow-hidden cursor-pointer flex flex-col h-full transform hover:-translate-y-1">
              <div className="p-8 flex-grow">
                <div className="flex justify-between items-start mb-6">
                  <h2 className="text-2xl font-bold text-gray-800 group-hover:text-blue-600 transition-colors">
                    {project.name}
                  </h2>
                  <span className="bg-blue-50 text-blue-700 text-xs font-bold px-3 py-1 rounded-full uppercase tracking-wider">
                    進行中
                  </span>
                </div>
                <p className="text-gray-600 mb-8 leading-relaxed">
                  {project.description}
                </p>

                {/* 簡易進捗表示（ダミー） */}
                <div className="space-y-2">
                  <div className="flex justify-between text-sm">
                    <span className="font-medium text-gray-700">全体進捗</span>
                    <span className="font-bold text-blue-600">65%</span>
                  </div>
                  <div className="w-full bg-gray-100 rounded-full h-3">
                    <div className="bg-gradient-to-r from-blue-500 to-indigo-600 h-3 rounded-full w-[65%] shadow-sm"></div>
                  </div>
                </div>
              </div>

              <div className="px-8 py-4 bg-gray-50 border-t border-gray-100 flex justify-between items-center group-hover:bg-blue-50 transition-colors">
                <div className="text-sm">
                  <span className="text-gray-500">納期: </span>
                  <span className="font-semibold text-gray-800">{project.deadline}</span>
                </div>
                <span className="text-blue-600 font-bold flex items-center group-hover:translate-x-1 transition-transform">
                  詳細を見る
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 ml-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                  </svg>
                </span>
              </div>
            </div>
          </Link>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="app/project/[id]/page.tsx">
import Link from 'next/link';
import { notFound } from 'next/navigation';
import { aggregateProgress } from '@/app/utils';
import { SummaryCard } from '@/app/components/SummaryCard';
import { mockStore } from '@/lib/mockStore';
import ProjectClientContent from './ProjectClientContent';

interface PageProps {
    params: Promise<{
        id: string;
    }>;
}

/**
 * プロジェクト別進捗ページ（サーバー側）
 */
export default async function ProjectDetailPage(props: PageProps) {
    const params = await props.params;
    const projectId = parseInt(params.id);
    if (isNaN(projectId)) {
        notFound();
    }

    const project = await mockStore.getProject(projectId);
    if (!project) {
        notFound();
    }

    // データの取得
    const parts = await mockStore.getParts(projectId);
    const partItems = await mockStore.getPartItems(projectId);

    const totalInventory = partItems.length;
    const inProgress = partItems.filter(item => item.status !== 'ASSEMBLED').length;

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const completedToday = partItems.filter(item =>
        item.completed_at && new Date(item.completed_at) >= today
    ).length;

    // 表示データの集計
    const progressData = aggregateProgress(parts, partItems);

    return (
        <div className="bg-gray-50 min-h-screen p-4 sm:p-6 lg:p-8 font-sans">
            <header className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-8 gap-4">
                <div>
                    <Link href="/" className="text-blue-600 hover:text-blue-800 mb-2 inline-block font-medium">
                        ← プロジェクト一覧へ戻る
                    </Link>
                    <h1 className="text-3xl font-bold text-gray-800">
                        {project.name}
                    </h1>
                    <p className="text-gray-600 mt-1">{project.description}</p>
                </div>
                <div className="flex gap-3">
                    <Link href={`/print?project_id=${projectId}`}>
                        <span className="bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-blue-700 transition-all cursor-pointer inline-block">
                            3Dプリント登録
                        </span>
                    </Link>
                </div>
            </header>

            {/* サマリーカード */}
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
                <SummaryCard title="総在庫数" value={totalInventory} />
                <SummaryCard title="仕掛品数" value={inProgress} valueColor="text-orange-500" />
                <SummaryCard title="本日完了数" value={completedToday} valueColor="text-green-500" />
            </div>

            {/* インタラクティブな一覧・カート機能 (クライアントコンポーネント) */}
            <ProjectClientContent
                progressData={progressData}
                parts={parts}
                partItems={partItems}
                projectId={projectId}
            />
        </div>
    );
}
</file>

<file path="package.json">
{
  "name": "sn-923",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@dnd-kit/core": "^6.3.1",
    "@dnd-kit/sortable": "^10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "@react-three/drei": "^10.7.7",
    "@react-three/fiber": "^9.5.0",
    "@tailwindcss/postcss": "^4.1.18",
    "@types/three": "^0.182.0",
    "firebase": "^12.8.0",
    "lucide-react": "^0.563.0",
    "next": "^16.1.6",
    "react": "^19.2.4",
    "react-dom": "^19.2.4",
    "three": "^0.182.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "@types/react": "^19.2.10",
    "@types/react-dom": "^19.2.3",
    "autoprefixer": "^10.4.23",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.18",
    "typescript": "^5.3.0"
  }
}
</file>

<file path="app/item/[id]/page.tsx">
import { mockStore } from '@/lib/mockStore'
import { updateProcess } from '@/app/actions/updateProcess'
import { consumeItem } from '@/app/actions/consumeItem'
import { reportDefect } from '@/app/actions/reportDefect' // アクションをインポート
import { PROCESSES } from '@/app/constants'
import Link from 'next/link'

export default async function ItemPage(props: { params: Promise<{ id: string }> }) {
  const params = await props.params;
  const id = parseInt(params.id, 10);
  const data = await mockStore.getPartItem(id);

  if (!data) {
    return <div className="p-8">アイテムが見つかりませんでした</div>;
  }

  return (
    <div className="p-8 max-w-2xl mx-auto bg-white shadow-lg rounded-xl mt-10 border border-gray-100">
      <Link href={`/project/${data.parts.project_id}`} className="text-sm text-blue-600 hover:underline mb-6 inline-block font-bold">
        ← プロジェクト進捗に戻る
      </Link>

      <div className="flex justify-between items-start mb-6">
        <h1 className="text-3xl font-black text-gray-900">{data.parts.part_number}</h1>
        <span className={`px-3 py-1 rounded-full text-xs font-bold ${data.status === 'DEFECTIVE' ? 'bg-red-100 text-red-600' : 'bg-blue-100 text-blue-600'}`}>
          ID: {id}
        </span>
      </div>

      {/* ステータス表示 */}
      <div className={`p-4 rounded-lg mb-8 border ${data.status === 'DEFECTIVE' ? 'bg-red-50 border-red-200' : 'bg-blue-50 border-blue-100'}`}>
        <p className="text-sm font-bold text-gray-500 uppercase tracking-wider">Current Status</p>
        <p className={`text-2xl font-black ${data.status === 'DEFECTIVE' ? 'text-red-700' : 'text-blue-800'}`}>
          {PROCESSES.find(p => p.key === data.status)?.name || data.status}
        </p>
      </div>

      <div className="space-y-10">
        {/* 1. 通常の工程更新 */}
        <section>
          <h2 className="text-sm font-bold text-gray-400 uppercase mb-3">工程を進める</h2>
          <form action={async (formData) => {
            'use server'
            const next = formData.get('next') as string;
            await updateProcess(id, next, data.parts.project_id);
          }} className="flex gap-2">
            <select name="next" defaultValue={data.status} className="flex-1 p-3 border rounded-lg font-bold">
              {PROCESSES.map(proc => <option key={proc.key} value={proc.key}>{proc.name}</option>)}
            </select>
            <button className="bg-gray-800 text-white px-6 py-3 rounded-lg font-bold hover:bg-black transition-colors">更新</button>
          </form>
        </section>

        {/* 2. 不良報告セクション（ここが重要） */}
        {data.status !== 'DEFECTIVE' && (
          <section className="p-6 border-2 border-red-200 rounded-2xl bg-red-50/50">
            <h2 className="text-lg font-black text-red-700 mb-2 flex items-center gap-2">
              ⚠️ 不良・再製作の報告
            </h2>
            <p className="text-sm text-red-600 mb-4 font-medium">
              この個体に欠陥がある場合、ここで報告します。この個体は「不良」として記録され、自動的に「未プリント」の新しいジョブが作成されます。
            </p>
            <form action={async (formData) => {
              'use server'
              const reason = formData.get('reason') as string;
              await reportDefect(id, reason);
            }} className="space-y-3">
              <input
                name="reason"
                placeholder="不良理由（例：積層剥離、寸法誤差）"
                className="w-full p-3 border-2 border-red-100 rounded-xl focus:border-red-500 outline-none bg-white font-medium"
                required
              />
              <button className="w-full bg-red-600 text-white font-black py-4 rounded-xl hover:bg-red-700 transition-all shadow-lg active:scale-[0.98]">
                不良を確定し、再製作を依頼
              </button>
            </form>
          </section>
        )}

        {/* 3. 完了処理 */}
        <section>
          <form action={async () => {
            'use server'
            await consumeItem(id);
          }}>
            <button className="w-full border-2 border-green-600 text-green-600 font-black py-4 rounded-xl hover:bg-green-50 transition-colors">
              組み込み完了（ストックから除外）
            </button>
          </form>
        </section>
      </div>
    </div>
  )
}
</file>

<file path="app/project/[id]/ProjectClientContent.tsx">
'use client';

import React, { useState } from 'react';
import {
    DndContext,
    DragOverlay,
    closestCorners,
    KeyboardSensor,
    PointerSensor,
    useSensor,
    useSensors,
    DragEndEvent,
    DragStartEvent,
} from '@dnd-kit/core';
import {
    sortableKeyboardCoordinates,
} from '@dnd-kit/sortable';
import { CartModal } from '@/app/components/CartModal';
import { PreviewModal } from '@/app/components/PreviewModal';
import { Part, PartItem, ProcessStatus } from '@/app/types';
import { updateItemStatus } from '@/app/actions/updateItemStatus';
import { SwimlaneRow } from '@/app/components/swimlane/SwimlaneRow';
import { SwimlaneItem } from '@/app/components/swimlane/SwimlaneItem';

// --- Main Component ---

export default function ProjectClientContent({
    progressData,
    parts,
    partItems: initialItems,
    projectId
}: {
    progressData: any[],
    parts: Part[],
    partItems: PartItem[],
    projectId: number
}) {
    const [items, setItems] = useState<PartItem[]>(initialItems);
    const [selectedIds, setSelectedIds] = useState<number[]>([]);
    const [isCartOpen, setIsCartOpen] = useState(false);
    const [activeId, setActiveId] = useState<string | null>(null);
    const [previewItem, setPreviewItem] = useState<any | null>(null);

    const sensors = useSensors(
        useSensor(PointerSensor, {
            activationConstraint: {
                distance: 5, // Requires slight movement to start, helps preventing accidental clicks
            },
        }),
        useSensor(KeyboardSensor, {
            coordinateGetter: sortableKeyboardCoordinates,
        })
    );

    const handleDragStart = (event: DragStartEvent) => {
        setActiveId(event.active.id as string);
    };

    const handleDragEnd = async (event: DragEndEvent) => {
        const { active, over } = event;
        setActiveId(null);

        if (!over) return;

        // Parse IDs
        const activeIdStr = active.id as string;
        const itemId = parseInt(activeIdStr.split('-')[1], 10);

        let targetStatus: string | undefined;

        const overIdStr = over.id as string;

        if (overIdStr.startsWith('container-')) {
            // Dropped on a container (SwimlaneCell)
            const parts = overIdStr.split('-');
            // container-{partId}-{status}
            // If status has hyphens, we need to join the rest
            targetStatus = parts.slice(2).join('-');
        } else if (overIdStr.startsWith('item-')) {
            // Dropped on another item
            const overItemId = parseInt(overIdStr.split('-')[1], 10);
            const overItem = items.find(i => i.id === overItemId);
            if (overItem) {
                targetStatus = overItem.status;
            }
        }

        if (targetStatus) {
            const item = items.find(i => i.id === itemId);

            // Only update if status changed
            if (item && item.status !== targetStatus) {
                // Optimistic UI update
                setItems(prev => prev.map(i =>
                    i.id === itemId ? { ...i, status: targetStatus as ProcessStatus } : i
                ));

                // Call Server Action
                const result = await updateItemStatus(itemId, targetStatus);
                if (!result.success) {
                    // Rollback on failure
                    setItems(prev => prev.map(i =>
                        i.id === itemId ? { ...i, status: item.status } : i
                    ));
                    alert(`Failed to update status: ${result.error}`);
                }
            }
        }
    };

    const activeItem = activeId
        ? items.find(i => `item-${i.id}` === activeId)
        : null;

    // Cart Logic
    const cartItems = items
        .filter(i => selectedIds.includes(i.id))
        .map(i => {
            const part = parts.find(p => p.id === i.part_id);
            return {
                id: i.id,
                part_number: part?.part_number || `Part-${i.part_id}`,
                count: 1
            };
        });

    return (
        <div className="h-[calc(100vh-100px)] w-full flex flex-col bg-gray-50/50">
            {/* Main Content Area - Horizontal Scroll */}
            <DndContext
                sensors={sensors}
                collisionDetection={closestCorners}
                onDragStart={handleDragStart}
                onDragEnd={handleDragEnd}
            >
                <div className="
                    flex-1 flex overflow-x-auto overflow-y-hidden gap-4 p-4 md:p-6
                    snap-x snap-mandatory md:snap-none
                    scrollbar-thin scrollbar-thumb-gray-300 scrollbar-track-transparent
                ">
                    {parts.map(part => (
                        <SwimlaneRow
                            key={part.id}
                            part={part}
                            items={items.filter(i => i.part_id === part.id)}
                            onPreview={(item) => {
                                const part = parts.find(p => p.id === item.part_id);
                                setPreviewItem({
                                    ...item,
                                    part_number: part?.part_number
                                });
                            }}
                        />
                    ))}

                    {/* Spacer for last item to be fully visible on mobile */}
                    <div className="w-4 shrink-0 md:hidden" />
                </div>

                <DragOverlay>
                    {activeItem ? (
                        <div className="w-64"> {/* Constrain width of overlay */}
                            <SwimlaneItem
                                item={{
                                    ...activeItem,
                                    part_number: parts.find(p => p.id === activeItem.part_id)?.part_number
                                }}
                                isOverlay
                                onPreview={() => { }}
                            />
                        </div>
                    ) : null}
                </DragOverlay>
            </DndContext>

            {/* Cart UI - Floating Action Button Style */}
            {selectedIds.length > 0 && (
                <div className="fixed bottom-8 right-8 z-50">
                    <button
                        onClick={() => setIsCartOpen(true)}
                        className="bg-gray-900 text-white px-6 py-3 rounded-full shadow-xl hover:bg-black transition-transform hover:scale-105 flex items-center gap-2"
                    >
                        <span className="font-bold">{selectedIds.length}</span>
                        <span>items selected</span>
                    </button>
                </div>
            )}

            <CartModal
                isOpen={isCartOpen}
                onClose={() => setIsCartOpen(false)}
                items={cartItems}
                onDownload={() => alert("Zipダウンロードを開始します")}
            />

            <PreviewModal
                isOpen={!!previewItem}
                onClose={() => setPreviewItem(null)}
                partNumber={previewItem?.part_number || ''}
                itemId={previewItem?.id}
                status={previewItem?.status}
                projectId={projectId}
            />
        </div>
    );
}
</file>

<file path="app/print/page.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import Link from 'next/link';
import { useRouter, useSearchParams } from 'next/navigation';
import { PROCESSES } from '../constants';
import { createPrinted } from '../actions/createPrinted';
import { parseFileName, ParsedFileInfo } from '@/lib/utils/parseFileName';
import { ProcessStatus } from '../types';

import { Suspense } from 'react';

function PrintRegistrationContent() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const projectIdStr = searchParams.get('project_id');
  const projectId = projectIdStr ? parseInt(projectIdStr) : null;

  const [selectedFiles, setSelectedFiles] = useState<File[]>([]);
  const [parsedInfos, setParsedInfos] = useState<(ParsedFileInfo & { file: File })[]>([]);
  const [targetStatus, setTargetStatus] = useState<ProcessStatus>('PRINTED');
  const [isSubmitting, setIsSubmitting] = useState(false);

  // ファイル選択時の解析処理
  useEffect(() => {
    if (selectedFiles.length > 0) {
      const infos = selectedFiles.map(file => ({
        ...parseFileName(file.name),
        file
      }));
      setParsedInfos(infos);
    } else {
      setParsedInfos([]);
    }
  }, [selectedFiles]);

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (files) {
      setSelectedFiles(Array.from(files));
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (selectedFiles.length === 0 || !projectId) {
      alert('ファイルを選択し、プロジェクトIDを指定してください。');
      return;
    }

    const invalidFiles = parsedInfos.filter(info => !info.isValid);
    if (invalidFiles.length > 0) {
      alert('解析に失敗したファイルが含まれています。修正または削除してください。');
      return;
    }

    setIsSubmitting(true);

    try {
      // 順次登録（並列にするとFirestoreのID採番でぶつかる可能性があるため、ここでは順次処理）
      for (const info of parsedInfos) {
        const arrayBuffer = await info.file.arrayBuffer();
        await createPrinted(
          arrayBuffer,
          info.file.name,
          projectId,
          info.quantity,
          targetStatus
        );
      }

      alert(`${parsedInfos.length} 件の部品登録が完了しました。`);
      const redirectPath = `/project/${projectId}`;
      router.push(redirectPath);
      router.refresh();
    } catch (error) {
      alert('エラーが発生しました: ' + (error instanceof Error ? error.message : '不明なエラー'));
      console.error(error);
    } finally {
      setIsSubmitting(false);
    }
  };

  const backHref = projectId ? `/project/${projectId}` : '/';

  return (
    <div className="bg-gray-50 min-h-screen p-4 sm:p-8 font-sans">
      <div className="max-w-3xl mx-auto">
        <header className="mb-8">
          <Link href={backHref} className="text-blue-600 hover:underline mb-2 inline-block">
            ← {projectId ? 'プロジェクト別進捗に戻る' : 'ダッシュボードに戻る'}
          </Link>
          <h1 className="text-3xl font-bold text-gray-800">3Dプリント一括追加登録</h1>
          <p className="text-gray-500 mt-2">STLファイル名から部品情報を自動取得して登録します。</p>
        </header>

        <form onSubmit={handleSubmit} className="bg-white rounded-xl shadow-lg p-6 space-y-6">
          {/* STLファイルアップロード */}
          <div className={`border-2 border-dashed rounded-lg p-8 text-center transition-colors ${selectedFiles.length > 0 ? 'border-blue-400 bg-blue-50' : 'border-gray-300 hover:border-blue-500'
            }`}>
            <input
              type="file"
              accept=".stl"
              onChange={handleFileChange}
              multiple
              className="hidden"
              id="stl-upload"
            />
            <label htmlFor="stl-upload" className="cursor-pointer">
              <div className="text-gray-600">
                {selectedFiles.length > 0 ? (
                  <div className="space-y-2">
                    <p className="font-semibold text-blue-600 text-lg">{selectedFiles.length} 個のファイルを選択中</p>
                    <p className="text-sm text-gray-500">クリックしてファイルを変更・追加</p>
                  </div>
                ) : (
                  <div className="space-y-2">
                    <div className="text-4xl">📁</div>
                    <p className="font-medium">CADから出力したSTLファイルをアップロード</p>
                    <p className="text-sm text-gray-400">複数選択が可能です（クリックまたはドラッグ＆ドロップ）</p>
                  </div>
                )}
              </div>
            </label>
          </div>

          {/* 解析プレビューリスト */}
          {parsedInfos.length > 0 && (
            <div className="space-y-3">
              <h3 className="font-bold text-gray-800 flex justify-between items-center">
                <span>解析プレビュー</span>
                <span className="text-sm font-normal text-gray-500">{parsedInfos.length} 件</span>
              </h3>
              <div className="border rounded-lg overflow-hidden divide-y bg-gray-50">
                {parsedInfos.map((info, idx) => (
                  <div key={idx} className={`p-4 flex items-center justify-between ${info.isValid ? 'bg-white' : 'bg-red-50'}`}>
                    <div className="flex-1 min-w-0">
                      <div className="flex items-center gap-2">
                        <span className="text-xs font-bold px-2 py-0.5 rounded bg-gray-100 text-gray-500">STL</span>
                        <p className="font-medium text-gray-900 truncate">{info.file.name}</p>
                      </div>
                      {info.isValid ? (
                        <div className="mt-1 flex items-center gap-4 text-sm text-gray-600">
                          <span>部品番号: <strong className="font-mono text-blue-600">{info.partNumber}</strong></span>
                          <span>個数: <strong className="text-gray-900">{info.quantity}</strong></span>
                        </div>
                      ) : (
                        <p className="mt-1 text-sm text-red-600 font-medium">⚠️ {info.errorMessage}</p>
                      )}
                    </div>
                    <div className="ml-4">
                      {info.isValid ? (
                        <span className="text-green-500 text-xl">✓</span>
                      ) : (
                        <span className="text-red-500 text-xl">✕</span>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          <div className="pt-4 border-t">
            {/* ステータス選択 */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">登録後の初期ステータス</label>
              <div className="flex gap-6">
                {['UNPRINTED', 'PRINTED'].map((status) => (
                  <label key={status} className="flex items-center cursor-pointer group">
                    <input
                      type="radio"
                      name="status"
                      value={status}
                      checked={targetStatus === status}
                      onChange={(e) => setTargetStatus(e.target.value as ProcessStatus)}
                      className="mr-2 h-5 w-5 text-blue-600 focus:ring-blue-500 border-gray-300"
                    />
                    <span className={`text-sm font-medium transition-colors ${targetStatus === status ? 'text-blue-700' : 'text-gray-600 group-hover:text-gray-800'}`}>
                      {PROCESSES.find(p => p.key === status)?.name}
                    </span>
                  </label>
                ))}
              </div>
            </div>
          </div>

          <button
            type="submit"
            disabled={isSubmitting || selectedFiles.length === 0 || parsedInfos.some(i => !i.isValid)}
            className={`w-full text-white font-bold py-4 px-6 rounded-xl shadow-lg transition-all text-xl ${isSubmitting || selectedFiles.length === 0 || parsedInfos.some(i => !i.isValid)
                ? 'bg-gray-300 cursor-not-allowed'
                : 'bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 active:transform active:scale-[0.98]'
              }`}
          >
            {isSubmitting ? (
              <span className="flex items-center justify-center">
                <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                {selectedFiles.length} 件を登録処理中...
              </span>
            ) : `プリントジョブ ${selectedFiles.length} 件を登録実行`}
          </button>
        </form>
      </div>
    </div>
  );
}

export default function PrintRegistrationPage() {
  return (
    <Suspense fallback={<div className="min-h-screen flex items-center justify-center">読み込み中...</div>}>
      <PrintRegistrationContent />
    </Suspense>
  );
}
</file>

</files>
