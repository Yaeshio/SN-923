This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.continue/agents/new-config.yaml
.env,local
.firebaserc
.gitignore
app/actions/consumeItem.ts
app/actions/createPrinted.ts
app/actions/reportDefect.ts
app/actions/updateItemStatus.ts
app/actions/updateProcess.ts
app/components/CartModal.tsx
app/components/ModelViewer.tsx
app/components/PreviewModal.tsx
app/components/SummaryCard.tsx
app/constants.ts
app/data.ts
app/globals.css
app/item/[id]/page.tsx
app/layout.tsx
app/page.tsx
app/print/page.tsx
app/project/[id]/page.tsx
app/project/[id]/ProjectClientContent.tsx
app/types.ts
app/utils.ts
firebase-data/auth_export/accounts.json
firebase-data/auth_export/config.json
firebase-data/firebase-export-metadata.json
firebase-data/firestore_export/all_namespaces/all_kinds/all_namespaces_all_kinds.export_metadata
firebase-data/firestore_export/all_namespaces/all_kinds/output-0
firebase-data/firestore_export/firestore_export.overall_export_metadata
firebase-data/storage_export/buckets.json
firebase.json
firestore.indexes.json
firestore.rules
lib/firebase.ts
lib/mockStore.ts
next.config.js
package.json
postcss.config.js
public/models/PART-A.stl
README.md
scripts/seed-emulator.ts
tailwind.config.js
tsconfig.json
tsconfig.node.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".continue/agents/new-config.yaml">
# This is an example configuration file
# To learn more, see the full config.yaml reference: https://docs.continue.dev/reference

name: Example Config
version: 1.0.0
schema: v1

# Define which models can be used
# https://docs.continue.dev/customization/models
models:
  - name: my gpt-5
    provider: openai
    model: gpt-5
    apiKey: YOUR_OPENAI_API_KEY_HERE
  - uses: ollama/qwen2.5-coder-7b
  - uses: anthropic/claude-4-sonnet
    with:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}

# MCP Servers that Continue can access
# https://docs.continue.dev/customization/mcp-tools
mcpServers:
  - uses: anthropic/memory-mcp
</file>

<file path=".env,local">
# Firebase Project ID (Emulator用に 'demo-' を付ける)
NEXT_PUBLIC_FIREBASE_PROJECT_ID=demo-bom3d-sn923

# 各種エミュレータのポート番号（デフォルト）
NEXT_PUBLIC_FIREBASE_FIRESTORE_EMULATOR_HOST=localhost:8080
NEXT_PUBLIC_FIREBASE_AUTH_EMULATOR_HOST=http://localhost:9099
</file>

<file path=".gitignore">
# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local
.env

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
Thumbs.db
</file>

<file path="app/actions/updateItemStatus.ts">
'use server'

import { mockStore } from '@/lib/mockStore'
import { revalidatePath } from 'next/cache'

/**
 * 部品アイテムのステータスを更新するサーバーアクション
 * @param itemId - 部品アイテムのID
 * @param newStatus - 新しいステータス（工程）
 */
export async function updateItemStatus(itemId: string | number, newStatus: string) {
    try {
        await mockStore.updatePartItemStatus(itemId, newStatus);

        // キャッシュを更新してUIに反映
        revalidatePath('/');

        return { success: true };
    } catch (error) {
        console.error('Failed to update item status:', error);
        return { success: false, error: (error as Error).message };
    }
}
</file>

<file path="app/components/CartModal.tsx">
'use client';

import React from 'react';

interface CartItem {
    id: number;
    part_number: string;
    count: number;
}

interface CartModalProps {
    isOpen: boolean;
    onClose: () => void;
    items: CartItem[];
    onDownload: () => void;
}

export function CartModal({ isOpen, onClose, items, onDownload }: CartModalProps) {
    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[100] p-4">
            <div className="bg-white rounded-2xl shadow-2xl w-full max-w-2xl overflow-hidden">
                <div className="p-6 border-b border-gray-100 flex justify-between items-center">
                    <h2 className="text-2xl font-bold text-gray-800">プリント用カート</h2>
                    <button onClick={onClose} className="text-gray-400 hover:text-gray-600">
                        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>

                <div className="p-6 max-h-[60vh] overflow-y-auto">
                    {items.length === 0 ? (
                        <p className="text-center text-gray-500 py-8">カートに部品が入っていません。</p>
                    ) : (
                        <table className="w-full">
                            <thead className="text-xs text-gray-400 uppercase border-b">
                                <tr>
                                    <th className="text-left pb-2">部品番号</th>
                                    <th className="text-right pb-2">ダウンロード数量</th>
                                    <th className="text-right pb-2">ファイル名</th>
                                </tr>
                            </thead>
                            <tbody className="divide-y divide-gray-100">
                                {items.map((item) => (
                                    <tr key={item.id}>
                                        <td className="py-4 font-semibold text-gray-800">{item.part_number}</td>
                                        <td className="py-4 text-right">
                                            <input
                                                type="number"
                                                defaultValue={item.count}
                                                className="w-16 border rounded p-1 text-right"
                                            />
                                        </td>
                                        <td className="py-4 text-right text-sm text-gray-500 font-mono">
                                            {item.part_number}.stl
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    )}
                </div>

                <div className="p-6 bg-gray-50 flex gap-4">
                    <button
                        onClick={onClose}
                        className="flex-1 px-6 py-3 rounded-xl border border-gray-300 font-bold text-gray-600 hover:bg-white transition-colors"
                    >
                        戻る
                    </button>
                    <button
                        onClick={onDownload}
                        disabled={items.length === 0}
                        className="flex-1 px-6 py-3 rounded-xl bg-green-600 text-white font-bold hover:bg-green-700 transition-colors shadow-lg disabled:bg-gray-300"
                    >
                        Zipで一括ダウンロード
                    </button>
                </div>
            </div>
        </div>
    );
}
</file>

<file path="app/components/SummaryCard.tsx">
// app/dashboard/components/SummaryCard.tsx
import React from 'react';

interface SummaryCardProps {
  title: string;
  value: number | string;
  valueColor?: string;
}

export function SummaryCard({ title, value, valueColor = 'text-gray-800' }: SummaryCardProps) {
  return (
    <div className="bg-white p-6 rounded-xl shadow-lg flex items-center">
      <div>
        <p className="text-lg text-gray-500">{title}</p>
        <p className={`text-5xl font-extrabold ${valueColor}`}>{value}</p>
      </div>
    </div>
  );
}
</file>

<file path="firebase-data/auth_export/accounts.json">
{"kind":"identitytoolkit#DownloadAccountResponse","users":[]}
</file>

<file path="firebase-data/auth_export/config.json">
{"signIn":{"allowDuplicateEmails":false},"emailPrivacyConfig":{"enableImprovedEmailPrivacy":false}}
</file>

<file path="firebase-data/firebase-export-metadata.json">
{
  "version": "15.5.1",
  "firestore": {
    "version": "1.20.2",
    "path": "firestore_export",
    "metadata_file": "firestore_export/firestore_export.overall_export_metadata"
  },
  "database": {
    "version": "4.11.2",
    "path": "database_export"
  },
  "auth": {
    "version": "15.5.1",
    "path": "auth_export"
  },
  "storage": {
    "version": "15.5.1",
    "path": "storage_export"
  }
}
</file>

<file path="firebase-data/storage_export/buckets.json">
{
  "buckets": [
    {
      "id": "demo-no-project.appspot.com"
    }
  ]
}
</file>

<file path="firebase.json">
{
  "firestore": {
    "database": "(default)",
    "location": "nam5",
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  },
  "emulators": {
    "auth": {
      "port": 9099
    },
    "firestore": {
      "port": 8080
    },
    "database": {
      "port": 9000
    },
    "hosting": {
      "port": 5000
    },
    "storage": {
      "port": 9199
    },
    "ui": {
      "enabled": true
    },
    "singleProjectMode": true
  }
}
</file>

<file path="firestore.indexes.json">
{
  // Example (Standard Edition):
  //
  // "indexes": [
  //   {
  //     "collectionGroup": "widgets",
  //     "queryScope": "COLLECTION",
  //     "fields": [
  //       { "fieldPath": "foo", "arrayConfig": "CONTAINS" },
  //       { "fieldPath": "bar", "mode": "DESCENDING" }
  //     ]
  //   },
  //
  //  "fieldOverrides": [
  //    {
  //      "collectionGroup": "widgets",
  //      "fieldPath": "baz",
  //      "indexes": [
  //        { "order": "ASCENDING", "queryScope": "COLLECTION" }
  //      ]
  //    },
  //   ]
  // ]
  //
  // Example (Enterprise Edition):
  //
  // "indexes": [
  //   {
  //     "collectionGroup": "reviews",
  //     "queryScope": "COLLECTION_GROUP",
  //     "apiScope": "MONGODB_COMPATIBLE_API",
  //     "density": "DENSE",
  //     "multikey": false,
  //     "fields": [
  //       { "fieldPath": "baz", "mode": "ASCENDING" }
  //     ]
  //   },
  //   {
  //     "collectionGroup": "items",
  //     "queryScope": "COLLECTION_GROUP",
  //     "apiScope": "MONGODB_COMPATIBLE_API",
  //     "density": "SPARSE_ANY",
  //     "multikey": true,
  //     "fields": [
  //       { "fieldPath": "baz", "mode": "ASCENDING" }
  //     ]
  //   },
  // ]
  "indexes": [],
  "fieldOverrides": []
}
</file>

<file path="firestore.rules">
rules_version='2'

service cloud.firestore {
  match /databases/{database}/documents {
    match /{document=**} {
      // This rule allows anyone with your database reference to view, edit,
      // and delete all data in your database. It is useful for getting
      // started, but it is configured to expire after 30 days because it
      // leaves your app open to attackers. At that time, all client
      // requests to your database will be denied.
      //
      // Make sure to write security rules for your app before that time, or
      // else all client requests to your database will be denied until you
      // update your rules.
      allow read, write: if request.time < timestamp.date(2026, 3, 5);
    }
  }
}
</file>

<file path="next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
}

module.exports = nextConfig
</file>

<file path="postcss.config.js">
module.exports = {
  plugins: {
    '@tailwindcss/postcss': {},
  },
}
</file>

<file path="README.md">
# SN-923
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './app/**/*.{js,ts,jsx,tsx,mdx}',
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path=".firebaserc">
{
  "projects": {
    "default": "demo-bom3d-sn923"
  }
}
</file>

<file path="app/actions/reportDefect.ts">
'use server'

import { mockStore } from '@/lib/mockStore'
import { revalidatePath } from 'next/cache'

/**
 * 不良を報告し、再製作ジョブを生成するサーバーアクション
 * @param itemId - 不良が発生したアイテムのID
 * @param reason - 不良の理由
 */
export async function reportDefect(itemId: number | string, reason: string) {
    const id = typeof itemId === 'string' ? parseInt(itemId, 10) : itemId;

    const item = await mockStore.getPartItem(id);
    if (!item) {
        console.error(`Item ${id} not found`);
        return;
    }

    // 1. 現状のアイテムを「不良(DEFECTIVE)」にする
    await mockStore.updatePartItem(id, {
        status: 'DEFECTIVE'
    });

    // 2. 新しいジョブ（再製作）を生成する
    // 元のアイテムの情報を引き継ぎつつ、工程を「未プリント」に戻す
    await mockStore.addPartItem({
        part_id: item.part_id,
        storage_case: `${item.storage_case} (RE)`, // 再製作であることを示す
        status: 'UNPRINTED',
        completed_at: null
    });

    console.log(`Reported defect for item ${id}: ${reason}`);

    // キャッシュを更新
    revalidatePath('/');
    revalidatePath(`/item/${id}`);
    revalidatePath(`/project/${item.parts.project_id}`);
}
</file>

<file path="app/components/ModelViewer.tsx">
'use client';

import { Canvas, useLoader } from '@react-three/fiber';
import { OrbitControls, Stage } from '@react-three/drei';
import { useState, useEffect, Suspense } from 'react';
import { STLLoader } from 'three-stdlib';

function STLModel({ url }: { url: string }) {
    if (!url) return null;

    const geom = useLoader(STLLoader, url);

    return (
        /* rotation: [x, y, z] 
           Math.PI / 2 は 90度です。
           CADのZ上をThree.jsのY上に合わせるため、X軸を軸にマイナス90度回転させます。
        */
        <mesh
            geometry={geom}
            rotation={[-Math.PI / 2, 0, 0]}
        >
            <meshStandardMaterial color="#3b82f6" />
        </mesh>
    );
}

export function ModelViewer({ url }: { url: string }) {
    const [mounted, setMounted] = useState(false);

    useEffect(() => {
        setMounted(true);
    }, []);

    if (!mounted) {
        return <div className="w-full h-[400px] bg-gray-900 rounded-lg" />;
    }

    return (
        <div className="w-full h-[400px] bg-gray-900 rounded-lg">
            <Canvas shadows camera={{ position: [0, 0, 20], fov: 50 }}>
                <Suspense fallback={null}>
                    <Stage environment="city" intensity={0.5}>
                        <STLModel url={url} />
                    </Stage>
                </Suspense>
                <OrbitControls autoRotate />
            </Canvas>
        </div>
    );
}
</file>

<file path="app/constants.ts">
import { ProcessStatus } from './types';

export const PROCESSES: { key: ProcessStatus; name: string }[] = [
  { key: 'UNPRINTED', name: '未プリント' },
  { key: 'PRINTED', name: 'プリント済み' },
  { key: 'SURFACE_TREATMENT', name: '表面処理' },
  { key: 'CUTTING', name: '切削' },
  { key: 'PAINTING', name: '塗装' },
  { key: 'READY', name: '準備完了' },
];
</file>

<file path="app/globals.css">
@import "tailwindcss";
</file>

<file path="app/layout.tsx">
import './globals.css'
import type { Metadata } from "next"

export const metadata: Metadata = {
  title: "SN-923",
  description: "在庫管理アプリケーション",
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="ja">
      <body>{children}</body>
    </html>
  )
}
</file>

<file path="lib/firebase.ts">
import { initializeApp, getApps } from "firebase/app";
import { getFirestore, connectFirestoreEmulator } from "firebase/firestore";
import { getAuth, connectAuthEmulator } from "firebase/auth";

const projectId = process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID || "demo-bom3d-sn923";

const firebaseConfig = {
    apiKey: "fake-api-key", // Emulator用ダミー
    authDomain: `${projectId}.firebaseapp.com`,
    projectId: projectId,
    storageBucket: `${projectId}.appspot.com`,
    messagingSenderId: "123456789",
    appId: "1:123456789:web:abcdef"
};

const app = getApps().length === 0 ? initializeApp(firebaseConfig) : getApps()[0];
const db = getFirestore(app);
const auth = getAuth(app);

const isEmulator = process.env.NODE_ENV === 'development' || projectId.startsWith('demo-');

if (isEmulator) {
    const g = global as any;
    if (!g._firebase_emulators_connected) {
        // 環境変数からポートを取得、なければデフォルト
        // localhost よりも 127.0.0.1 のほうが安定するケースがあるため変更
        connectFirestoreEmulator(db, '127.0.0.1', 8080);
        connectAuthEmulator(auth, "http://127.0.0.1:9099");
        g._firebase_emulators_connected = true;
        console.log(`Connected to Firebase Emulators: ${projectId}`);
    }
}

export { db, auth };
</file>

<file path="scripts/seed-emulator.ts">
import { db } from '../lib/firebase';
import { projects, parts, partItems } from '../app/data';
import { collection, doc, setDoc, serverTimestamp } from 'firebase/firestore';

// @ts-ignore
process.env.NODE_ENV = 'development';

async function seed() {
    console.log('Seeding Firestore Emulator...');
    console.log('Connecting to Firestore (ensure Emulator is running on localhost:8080)...');

    // Projects
    console.log('Seeding Projects...');
    for (const project of projects) {
        const projectRef = doc(db, 'projects', String(project.id));
        await setDoc(projectRef, {
            ...project,
            // Ensure dates are compatible if strings
        });
    }

    // Parts
    console.log('Seeding Parts...');
    for (const part of parts) {
        const partRef = doc(db, 'parts', String(part.id));
        await setDoc(partRef, part);
    }

    // PartItems
    console.log('Seeding PartItems...');
    for (const item of partItems) {
        const itemRef = doc(db, 'partItems', String(item.id));
        await setDoc(itemRef, {
            ...item,
            // Convert Date object to Timestamp or keep as Date
            completed_at: item.completed_at ? item.completed_at : null,
            updated_at: serverTimestamp()
        });
    }

    console.log('Seeding completed!');
    process.exit(0);
}

seed().catch((error) => {
    console.error('Seeding failed:', error);
    process.exit(1);
});
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es2017",
    "useDefineForClassFields": true,
    "lib": [
      "es2020",
      "dom",
      "dom.iterable"
    ],
    "module": "esnext",
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
    /* Next.js */
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "incremental": true,
    /* Path mapping */
    "baseUrl": ".",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "allowJs": true,
    "strict": false,
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts"
  ],
  "exclude": [
    "node_modules"
  ]
}
</file>

<file path="app/components/PreviewModal.tsx">
'use client'

import { useState, useTransition } from 'react'
import { ModelViewer } from './ModelViewer'
import { PROCESSES } from '@/app/constants'
import { updateProcess } from '@/app/actions/updateProcess'
import { reportDefect } from '@/app/actions/reportDefect'

interface PreviewModalProps {
    isOpen: boolean
    onClose: () => void
    partNumber: string
    itemId?: number
    status?: string
    projectId?: number
}

export function PreviewModal({
    isOpen,
    onClose,
    partNumber,
    itemId,
    status,
    projectId
}: PreviewModalProps) {
    const [isPending, startTransition] = useTransition()
    const [defectReason, setDefectReason] = useState('')

    if (!isOpen) return null

    // 現在の工程より「前」の工程を抽出（差し戻し用）
    const currentIndex = PROCESSES.findIndex(p => p.key === status)
    const previousProcesses = PROCESSES.slice(0, currentIndex)

    const handleUpdateStatus = (statusKey: string) => {
        if (!itemId || !projectId) return
        startTransition(async () => {
            await updateProcess(itemId, statusKey, projectId)
            onClose()
        })
    }

    const handleReportDefect = () => {
        if (!itemId || !defectReason) return
        startTransition(async () => {
            await reportDefect(itemId, defectReason)
            setDefectReason('')
            onClose()
        })
    }

    return (
        <div className="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-[110] p-4">
            <div className="bg-white rounded-3xl w-full max-w-5xl max-h-[90vh] overflow-hidden flex flex-col shadow-2xl">

                {/* ヘッダー */}
                <div className="p-6 border-b flex justify-between items-center bg-gray-50">
                    <div>
                        <h3 className="text-2xl font-black text-gray-900">{partNumber}</h3>
                        <p className="text-sm text-gray-500 font-bold">ITEM ID: {itemId} / CURRENT: {status}</p>
                    </div>
                    <button
                        onClick={onClose}
                        className="w-10 h-10 flex items-center justify-center rounded-full hover:bg-gray-200 transition-colors text-2xl font-bold"
                    >
                        &times;
                    </button>
                </div>

                <div className="flex-1 flex flex-col md:flex-row overflow-hidden">
                    {/* 左側：3Dプレビュー */}
                    <div className="flex-[2] bg-gray-100 relative min-h-[300px]">
                        <ModelViewer url={`/models/${partNumber}.stl`} />
                        <div className="absolute bottom-4 left-4 bg-white/80 px-3 py-1 rounded text-xs font-bold text-gray-500">
                            3D PREVIEW MODE
                        </div>
                    </div>

                    {/* 右側：操作パネル */}
                    <div className="flex-1 border-l bg-white p-6 overflow-y-auto space-y-8">

                        {/* 1. 工程の差し戻し */}
                        <section>
                            <h4 className="text-sm font-black text-gray-400 uppercase tracking-widest mb-4">工程を差し戻す (手戻り)</h4>
                            <div className="grid grid-cols-1 gap-2">
                                {previousProcesses.length > 0 ? (
                                    previousProcesses.map((proc) => (
                                        <button
                                            key={proc.key}
                                            onClick={() => handleUpdateStatus(proc.key)}
                                            disabled={isPending}
                                            className="text-left px-4 py-3 border-2 border-orange-100 rounded-xl hover:border-orange-500 hover:bg-orange-50 transition-all group"
                                        >
                                            <span className="text-xs font-bold text-orange-400 block uppercase">{proc.key}へ戻す</span>
                                            <span className="font-bold text-gray-700 group-hover:text-orange-700">{proc.name}</span>
                                        </button>
                                    ))
                                ) : (
                                    <p className="text-sm text-gray-400 italic">差し戻せる前の工程はありません</p>
                                )}
                            </div>
                        </section>

                        <hr className="border-gray-100" />

                        {/* 2. 不良報告 */}
                        <section className="p-5 border-2 border-red-100 rounded-2xl bg-red-50/30">
                            <h4 className="text-lg font-black text-red-700 mb-2">不良を報告する</h4>
                            <p className="text-xs text-red-600 mb-4 leading-relaxed font-medium">
                                個体に欠陥がある場合、不良として確定させます。実行すると自動的に再製作ジョブが生成されます。
                            </p>
                            <div className="space-y-3">
                                <textarea
                                    value={defectReason}
                                    onChange={(e) => setDefectReason(e.target.value)}
                                    placeholder="不良の理由を入力してください..."
                                    className="w-full p-3 border-2 border-red-100 rounded-xl text-sm focus:border-red-500 outline-none resize-none h-24 font-medium"
                                />
                                <button
                                    onClick={handleReportDefect}
                                    disabled={isPending || !defectReason}
                                    className={`w-full py-4 rounded-xl font-black transition-all shadow-md ${isPending || !defectReason
                                        ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                                        : 'bg-red-600 text-white hover:bg-red-700 active:scale-95'
                                        }`}
                                >
                                    {isPending ? '処理中...' : '不良確定 & 再製作依頼'}
                                </button>
                            </div>
                        </section>

                    </div>
                </div>
            </div>
        </div>
    )
}
</file>

<file path="app/utils.ts">
// app/utils.ts
import { Part, PartItem, ProgressData, ProcessStatus } from './types';
import { PROCESSES } from './constants';

export const aggregateProgress = (parts: Part[], partItems: PartItem[]): any[] => {
  return parts.map(part => {
    const items = partItems.filter(item => item.part_id === part.id);

    // この部品の中で最も「進んでいない」工程を現在の工程とする
    // (全て完了していれば READY となる)
    const processOrder = PROCESSES.map(p => p.key);
    const currentProcess = items.length > 0
      ? items.reduce((earliest, item) => {
        return processOrder.indexOf(item.status) < processOrder.indexOf(earliest)
          ? item.status
          : earliest;
      }, 'READY' as ProcessStatus)
      : 'UNPRINTED';

    return {
      id: part.id,
      part_number: part.part_number,
      status: currentProcess, // Rename field
      storage_cases: Array.from(new Set(items.map(i => i.storage_case))),
      count: items.length
    };
  });
};
</file>

<file path="app/actions/consumeItem.ts">
'use server'

import { mockStore } from '@/lib/mockStore'
import { revalidatePath } from 'next/cache'

/**
 * 部品アイテムを消費済みにするサーバーアクション
 * @param itemId - 消費する部品アイテムのID
 */
export async function consumeItem(itemId: string | number) {
  const id = typeof itemId === 'string' ? parseInt(itemId, 10) : itemId;

  await mockStore.updatePartItem(id, {
    status: 'READY', // 本来のロジックに合わせてREADYにするか、または別のステータス
    completed_at: new Date(),
    storage_case: 'CONSUMED' // 便宜上の表記
  });

  console.log(`Consumed item ${id}`);

  revalidatePath('/');
  revalidatePath(`/item/${id}`);
}
</file>

<file path="app/actions/createPrinted.ts">
'use server'

import { mockStore } from '@/lib/mockStore'
import { revalidatePath } from 'next/cache'

/**
 * 3Dプリントされた新しい部品アイテムを作成するサーバーアクション
 * @param partId - 部品のID
 * @param qty - 数量
 * @param storageCaseLabel - 保管ケースのラベル（mock版では文字列）
 */
export async function createPrinted(
  partId: string | number,
  qty: number,
  storageCaseLabel: string
) {
  const pId = typeof partId === 'string' ? parseInt(partId, 10) : partId;

  // 指定された数量だけループを実行
  for (let i = 0; i < qty; i++) {
    await mockStore.addPartItem({
      part_id: pId,
      status: 'PRINTED',
      storage_case: storageCaseLabel,
      completed_at: null
    });
  }

  console.log(`Created ${qty} items for part ${pId}`);

  revalidatePath('/');
}
</file>

<file path="app/data.ts">
// app/data.ts
import { Part, PartItem, Project } from './types';

export const projects: Project[] = [
  { id: 1, name: '次世代ドローン開発', description: '高解像度カメラ搭載の新型ドローン開発プロジェクト', deadline: '2026-06-30' },
  { id: 2, name: '搬送ロボット製作', description: '倉庫内自動配送を行う自律走行ロボットの試作', deadline: '2026-04-15' }
];

export const parts: Part[] = [
  { id: 1, part_number: 'DRONE-ARM-01', project_id: 1 },
  { id: 2, part_number: 'DRONE-BODY-01', project_id: 1 },
  { id: 3, part_number: 'DRONE-PROP-01', project_id: 1 },
  { id: 4, part_number: 'ROBO-WHEEL-X', project_id: 2 }
];

export const partItems: PartItem[] = [
  // DRONE-ARM-01 (id: 1) - 分散配置
  { id: 101, part_id: 1, storage_case: 'Case-A1', status: 'UNPRINTED', completed_at: null },
  { id: 102, part_id: 1, storage_case: 'Case-A1', status: 'PRINTED', completed_at: null },
  { id: 103, part_id: 1, storage_case: 'Case-A2', status: 'PRINTED', completed_at: null },
  { id: 104, part_id: 1, storage_case: 'Case-A3', status: 'SURFACE_TREATMENT', completed_at: null },
  { id: 105, part_id: 1, storage_case: 'Case-A4', status: 'READY', completed_at: new Date() },

  // DRONE-BODY-01 (id: 2) - 特定工程に集中
  { id: 201, part_id: 2, storage_case: 'Case-B1', status: 'CUTTING', completed_at: null },
  { id: 202, part_id: 2, storage_case: 'Case-B1', status: 'CUTTING', completed_at: null },
  { id: 203, part_id: 2, storage_case: 'Case-B2', status: 'PAINTING', completed_at: null },

  // DRONE-PROP-01 (id: 3) - 少ないアイテム、不良あり
  { id: 301, part_id: 3, storage_case: 'Case-C1', status: 'UNPRINTED', completed_at: null },
  { id: 302, part_id: 3, storage_case: 'Case-C2', status: 'DEFECTIVE', completed_at: null },

  // ROBO-WHEEL-X (id: 4) - 別プロジェクト
  { id: 401, part_id: 4, storage_case: 'Case-R1', status: 'READY', completed_at: new Date() }
];
</file>

<file path="app/types.ts">
export type ProcessStatus =
  | 'UNPRINTED'
  | 'PRINTED'
  | 'SURFACE_TREATMENT'
  | 'CUTTING'
  | 'PAINTING'
  | 'READY'
  | 'DEFECTIVE';

export interface Project {
  id: number;
  name: string;
  description: string;
  deadline: string;
}

export interface Part {
  id: number;
  part_number: string;
  project_id: number;
}

export interface PartItem {
  id: number;
  part_id: number;
  storage_case: string;
  status: ProcessStatus;
  completed_at: Date | null;
  updated_at?: any;
}

export interface ProgressData {
  part_number: string;
  storage_cases: string[];
  counts: Record<ProcessStatus, number>;
}
</file>

<file path="lib/mockStore.ts">
import { Part, PartItem, Project, ProcessStatus } from '@/app/types';
import { db } from './firebase';
import {
    collection,
    getDocs,
    doc,
    getDoc,
    updateDoc,
    setDoc,
    query,
    where,
    Timestamp,
    serverTimestamp
} from 'firebase/firestore';

// Firestoreのデータコンバーター（Date型の復元など）
const dateConverter = (data: any): any => {
    if (!data) return data;
    const result = { ...data };
    // completed_atなどのTimestampをDateに戻す
    Object.keys(result).forEach(key => {
        if (result[key] instanceof Timestamp) {
            result[key] = result[key].toDate();
        }
    });
    return result;
};

export const mockStore = {
    getProjects: async (): Promise<Project[]> => {
        const snapshot = await getDocs(collection(db, 'projects'));
        return snapshot.docs.map(doc => ({
            id: Number(doc.id),
            ...dateConverter(doc.data())
        })) as Project[];
    },

    getProject: async (id: number): Promise<Project | null> => {
        const docRef = doc(db, 'projects', String(id));
        const span = await getDoc(docRef);
        if (!span.exists()) return null;
        return { id: Number(span.id), ...dateConverter(span.data()) } as Project;
    },

    getParts: async (projectId?: number): Promise<Part[]> => {
        let q;
        if (projectId) {
            q = query(collection(db, 'parts'), where('project_id', '==', projectId));
        } else {
            q = collection(db, 'parts');
        }
        const snapshot = await getDocs(q);
        return snapshot.docs.map(doc => ({
            id: Number(doc.id),
            ...dateConverter(doc.data())
        })) as Part[];
    },

    getPartItems: async (projectId?: number): Promise<PartItem[]> => {
        // プロジェクトID指定がある場合、まず対象のPartを取得
        let targetPartIds: number[] | null = null;
        if (projectId) {
            const parts = await mockStore.getParts(projectId);
            targetPartIds = parts.map(p => p.id);
            if (targetPartIds.length === 0) return [];
        }

        // Firestoreの 'in' 句は最大10個までなので、ここでは全件取得してJSでフィルタリングする方式を採用
        // (プロトタイプのため簡易実装)
        const snapshot = await getDocs(collection(db, 'partItems'));
        const items = snapshot.docs.map(doc => ({
            id: Number(doc.id),
            ...dateConverter(doc.data())
        })) as PartItem[];

        if (targetPartIds) {
            return items.filter(item => targetPartIds!.includes(item.part_id));
        }
        return items;
    },

    getPartItem: async (id: number): Promise<(PartItem & { parts: Part }) | null> => {
        const itemRef = doc(db, 'partItems', String(id));
        const itemSnap = await getDoc(itemRef);

        if (!itemSnap.exists()) return null;
        const itemData = { id: Number(itemSnap.id), ...dateConverter(itemSnap.data()) } as PartItem;

        // 関連するPartを取得
        const partRef = doc(db, 'parts', String(itemData.part_id));
        const partSnap = await getDoc(partRef);

        if (!partSnap.exists()) {
            throw new Error(`Part not found for item ${id}`);
        }
        const partData = { id: Number(partSnap.id), ...dateConverter(partSnap.data()) } as Part;

        return { ...itemData, parts: partData };
    },

    updatePartItem: async (id: number, updates: Partial<PartItem>): Promise<void> => {
        const docRef = doc(db, 'partItems', String(id));
        await updateDoc(docRef, updates);
    },

    updatePartItemStatus: async (id: string | number, newStatus: string): Promise<void> => {
        const docRef = doc(db, 'partItems', String(id));
        await updateDoc(docRef, {
            status: newStatus as ProcessStatus,
            updated_at: serverTimestamp()
        });
    },

    addPartItem: async (item: Omit<PartItem, 'id'>): Promise<PartItem> => {
        // IDの自動採番（Max + 1）
        const snapshot = await getDocs(collection(db, 'partItems'));
        const ids = snapshot.docs.map(d => Number(d.id));
        const newId = ids.length > 0 ? Math.max(...ids) + 1 : 1;

        const newItem = { ...item, id: newId };
        const docRef = doc(db, 'partItems', String(newId));
        await setDoc(docRef, newItem);

        return newItem as PartItem;
    },

    // 互換性のためのダミーメソッド
    saveToLocalStorage: () => {
        console.warn('saveToLocalStorage is deprecated in Firestore mode');
    },

    loadFromLocalStorage: () => {
        console.warn('loadFromLocalStorage is deprecated in Firestore mode');
    }
};
</file>

<file path="app/actions/updateProcess.ts">
'use server'

import { mockStore } from '@/lib/mockStore'
import { ProcessStatus } from '@/app/types'
import { revalidatePath } from 'next/cache'

/**
 * 部品アイテムの工程を更新するサーバーアクション
 * @param itemId - 更新する部品アイテムのID
 * @param nextProcess - 次の工程名
 */
export async function updateProcess(
  itemId: string | number,
  nextProcess: string,
  projectId?: number
) {
  // 文字列IDを数値に変換（mockStoreの仕様に合わせる）
  const id = typeof itemId === 'string' ? parseInt(itemId, 10) : itemId;

  // メモリ上のデータを更新
  await mockStore.updatePartItem(id, {
    status: nextProcess as ProcessStatus,
    // READYに移行した場合は完了日時を設定
    completed_at: nextProcess === 'READY' ? new Date() : null
  });

  // 工程ログはモック版では省略、または必要なら追加
  console.log(`Updated item ${id} to status ${nextProcess}`);

  // キャッシュを更新してUIに反映
  revalidatePath('/');
  revalidatePath(`/item/${id}`);
  if (projectId) {
    revalidatePath(`/project/${projectId}`);
  }
}
</file>

<file path="app/page.tsx">
import Link from 'next/link';
import { mockStore } from '@/lib/mockStore';

/**
 * プロジェクト一覧ダッシュボード
 */
export default async function ProjectsDashboardPage() {
  const projects = await mockStore.getProjects();

  return (
    <div className="bg-gray-50 min-h-screen p-4 sm:p-6 lg:p-8 font-sans">
      <header className="mb-12 text-center">
        <h1 className="text-4xl font-extrabold text-gray-900 mb-4 tracking-tight">
          BOM進捗管理システム
        </h1>
        <p className="text-xl text-gray-600 max-w-2xl mx-auto">
          プロジェクトを選択して、部品の製造工程と進捗状況をリアルタイムで確認できます。
        </p>
      </header>

      <div className="max-w-6xl mx-auto grid grid-cols-1 md:grid-cols-2 gap-8">
        {projects.map((project) => (
          <Link key={project.id} href={`/project/${project.id}`}>
            <div className="group bg-white rounded-2xl shadow-sm hover:shadow-xl transition-all duration-300 border border-gray-100 overflow-hidden cursor-pointer flex flex-col h-full transform hover:-translate-y-1">
              <div className="p-8 flex-grow">
                <div className="flex justify-between items-start mb-6">
                  <h2 className="text-2xl font-bold text-gray-800 group-hover:text-blue-600 transition-colors">
                    {project.name}
                  </h2>
                  <span className="bg-blue-50 text-blue-700 text-xs font-bold px-3 py-1 rounded-full uppercase tracking-wider">
                    進行中
                  </span>
                </div>
                <p className="text-gray-600 mb-8 leading-relaxed">
                  {project.description}
                </p>

                {/* 簡易進捗表示（ダミー） */}
                <div className="space-y-2">
                  <div className="flex justify-between text-sm">
                    <span className="font-medium text-gray-700">全体進捗</span>
                    <span className="font-bold text-blue-600">65%</span>
                  </div>
                  <div className="w-full bg-gray-100 rounded-full h-3">
                    <div className="bg-gradient-to-r from-blue-500 to-indigo-600 h-3 rounded-full w-[65%] shadow-sm"></div>
                  </div>
                </div>
              </div>

              <div className="px-8 py-4 bg-gray-50 border-t border-gray-100 flex justify-between items-center group-hover:bg-blue-50 transition-colors">
                <div className="text-sm">
                  <span className="text-gray-500">納期: </span>
                  <span className="font-semibold text-gray-800">{project.deadline}</span>
                </div>
                <span className="text-blue-600 font-bold flex items-center group-hover:translate-x-1 transition-transform">
                  詳細を見る
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 ml-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                  </svg>
                </span>
              </div>
            </div>
          </Link>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="app/project/[id]/page.tsx">
import Link from 'next/link';
import { notFound } from 'next/navigation';
import { aggregateProgress } from '@/app/utils';
import { SummaryCard } from '@/app/components/SummaryCard';
import { mockStore } from '@/lib/mockStore';
import ProjectClientContent from './ProjectClientContent';

interface PageProps {
    params: Promise<{
        id: string;
    }>;
}

/**
 * プロジェクト別進捗ページ（サーバー側）
 */
export default async function ProjectDetailPage(props: PageProps) {
    const params = await props.params;
    const projectId = parseInt(params.id);
    if (isNaN(projectId)) {
        notFound();
    }

    const project = await mockStore.getProject(projectId);
    if (!project) {
        notFound();
    }

    // データの取得
    const parts = await mockStore.getParts(projectId);
    const partItems = await mockStore.getPartItems(projectId);

    const totalInventory = partItems.length;
    const inProgress = partItems.filter(item => item.status !== 'READY').length;

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const completedToday = partItems.filter(item =>
        item.completed_at && new Date(item.completed_at) >= today
    ).length;

    // 表示データの集計
    const progressData = aggregateProgress(parts, partItems);

    return (
        <div className="bg-gray-50 min-h-screen p-4 sm:p-6 lg:p-8 font-sans">
            <header className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-8 gap-4">
                <div>
                    <Link href="/" className="text-blue-600 hover:text-blue-800 mb-2 inline-block font-medium">
                        ← プロジェクト一覧へ戻る
                    </Link>
                    <h1 className="text-3xl font-bold text-gray-800">
                        {project.name}
                    </h1>
                    <p className="text-gray-600 mt-1">{project.description}</p>
                </div>
                <div className="flex gap-3">
                    <Link href={`/print?project_id=${projectId}`}>
                        <span className="bg-blue-600 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:bg-blue-700 transition-all cursor-pointer inline-block">
                            3Dプリント登録
                        </span>
                    </Link>
                </div>
            </header>

            {/* サマリーカード */}
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
                <SummaryCard title="総在庫数" value={totalInventory} />
                <SummaryCard title="仕掛品数" value={inProgress} valueColor="text-orange-500" />
                <SummaryCard title="本日完了数" value={completedToday} valueColor="text-green-500" />
            </div>

            {/* インタラクティブな一覧・カート機能 (クライアントコンポーネント) */}
            <ProjectClientContent
                progressData={progressData}
                parts={parts}
                partItems={partItems}
                projectId={projectId}
            />
        </div>
    );
}
</file>

<file path="app/project/[id]/ProjectClientContent.tsx">
'use client';

import React, { useState } from 'react';
import {
    DndContext,
    DragOverlay,
    closestCorners,
    KeyboardSensor,
    PointerSensor,
    useSensor,
    useSensors,
    DragEndEvent,
    DragStartEvent,
    useDroppable
} from '@dnd-kit/core';
import {
    SortableContext,
    sortableKeyboardCoordinates,
    verticalListSortingStrategy,
    useSortable
} from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { PROCESSES } from '@/app/constants';
import { CartModal } from '@/app/components/CartModal';
import { PreviewModal } from '@/app/components/PreviewModal';
import { Part, PartItem } from '@/app/types';
import { updateItemStatus } from '@/app/actions/updateItemStatus';

// --- Components ---

interface DraggableItemProps {
    item: PartItem & { part_number?: string }; // part_numberはデータにある場合とない場合がある
    isOverlay?: boolean;
    onPreview: (item: any) => void;
}

function DraggableItem({ item, isOverlay, onPreview }: DraggableItemProps) {
    const {
        attributes,
        listeners,
        setNodeRef,
        transform,
        transition,
        isDragging
    } = useSortable({ id: `item-${item.id}` });

    const style = {
        transform: CSS.Transform.toString(transform),
        transition,
        opacity: isDragging ? 0.3 : 1,
    };

    return (
        <div
            ref={setNodeRef}
            style={style}
            {...attributes}
            {...listeners}
            className={`
                bg-white p-2 rounded-md shadow-sm border border-gray-200 mb-2 cursor-grab active:cursor-grabbing
                hover:border-blue-400 transition-all text-xs
                ${isOverlay ? 'shadow-xl scale-105 border-blue-500' : ''}
            `}
        >
            <div className="flex justify-between items-center mb-1">
                <span className="font-bold text-gray-500">#{item.id}</span>
                <button
                    onClick={(e) => {
                        e.stopPropagation(); // ドラッグ動作と競合しないように
                        onPreview(item);
                    }}
                    onPointerDown={(e) => e.stopPropagation()} // 重要: ボタン押下でドラッグが始まらないようにする
                    className="text-[10px] bg-blue-50 text-blue-600 px-1.5 py-0.5 rounded hover:bg-blue-100"
                >
                    詳細
                </button>
            </div>
            <div className="text-[10px] text-gray-400 truncate font-mono">
                {item.storage_case || 'No Case'}
            </div>
        </div>
    );
}

interface SwimlaneCellProps {
    partId: number;
    status: string;
    items: PartItem[];
    onPreview: (item: any) => void;
}

function SwimlaneCell({ partId, status, items, onPreview }: SwimlaneCellProps) {
    // Droppable ID: container-{partId}-{status}
    const droppableId = `container-${partId}-${status}`;
    const { setNodeRef, isOver } = useDroppable({ id: droppableId });

    return (
        <div
            ref={setNodeRef}
            className={`
                flex-1 min-w-[140px] border-r border-gray-100 p-2 flex flex-col transition-colors
                ${isOver ? 'bg-blue-50/50' : 'bg-transparent'}
            `}
        >
            <SortableContext
                items={items.map(i => `item-${i.id}`)}
                strategy={verticalListSortingStrategy}
            >
                <div className="flex-1 min-h-[60px]"> {/* 空でもドロップできるように高さを確保 */}
                    {items.map(item => (
                        <DraggableItem key={item.id} item={item} onPreview={onPreview} />
                    ))}
                </div>
            </SortableContext>
        </div>
    );
}

interface SwimlaneRowProps {
    part: Part;
    items: PartItem[];
    onPreview: (item: any) => void;
}

function SwimlaneRow({ part, items, onPreview }: SwimlaneRowProps) {
    return (
        <div className="flex bg-white shadow-sm rounded-lg border border-gray-200 overflow-hidden mb-4 shrink-0">
            {/* 左端：部品情報（固定列） */}
            <div className="w-48 bg-gray-50 p-4 border-r border-gray-200 flex flex-col justify-center shrink-0">
                <h3 className="font-bold text-gray-800 text-sm mb-1">{part.part_number}</h3>
                <p className="text-xs text-gray-500">Total: {items.length} items</p>
            </div>

            {/* 右側：工程セル（横スクロール可能領域） */}
            <div className="flex-1 flex divide-x divide-gray-100 overflow-x-auto">
                {PROCESSES.map(proc => (
                    <SwimlaneCell
                        key={proc.key}
                        partId={part.id}
                        status={proc.key}
                        items={items.filter(i => i.status === proc.key)}
                        onPreview={onPreview}
                    />
                ))}
            </div>
        </div>
    );
}

// --- Main Component ---

export default function ProjectClientContent({
    progressData,
    parts,
    partItems: initialItems,
    projectId
}: {
    progressData: any[],
    parts: Part[],
    partItems: PartItem[],
    projectId: number
}) {
    const [items, setItems] = useState<PartItem[]>(initialItems);
    const [selectedIds, setSelectedIds] = useState<number[]>([]);
    const [isCartOpen, setIsCartOpen] = useState(false);
    const [activeId, setActiveId] = useState<string | null>(null);
    const [previewItem, setPreviewItem] = useState<any | null>(null);

    const sensors = useSensors(
        useSensor(PointerSensor, {
            activationConstraint: {
                distance: 5,
            },
        }),
        useSensor(KeyboardSensor, {
            coordinateGetter: sortableKeyboardCoordinates,
        })
    );

    const handleDragStart = (event: DragStartEvent) => {
        setActiveId(event.active.id as string);
    };

    const handleDragEnd = async (event: DragEndEvent) => {
        const { active, over } = event;
        setActiveId(null);

        if (!over) return;

        // IDのパース
        // Draggable ID: item-{itemId}
        const activeIdStr = active.id as string;
        const itemId = parseInt(activeIdStr.split('-')[1], 10);

        // Droppable ID: container-{partId}-{status}
        // または Sortable Item ID: item-{itemId} (同じカラム内の並び替え時などはこれに乗ることもあるが、Droppableコンテナで受けるのが基本)

        let targetStatus: string | undefined;
        // let targetPartId: number | undefined; // 今回はstatusだけわかればよいが、厳密にはPartの一致確認も可

        const overIdStr = over.id as string;

        if (overIdStr.startsWith('container-')) {
            const parts = overIdStr.split('-');
            // container-{partId}-{status}
            // partIdが数値の場合、parts[1]は数値文字列。statusは残りの部分だが、status自体にハイフンが含まれない前提
            // statusにハイフンが含まれる場合は slice で結合が必要
            // 今回のPROCESS_STATUSESはハイフンを含まない (UNDERSCOREは含む) ので大丈夫
            targetStatus = parts[2]; // status
        } else if (overIdStr.startsWith('item-')) {
            // アイテムの上にドロップした場合、そのアイテムの親コンテナのステータスを取得する必要がある
            // items配列から検索して特定する
            const overItemId = parseInt(overIdStr.split('-')[1], 10);
            const overItem = items.find(i => i.id === overItemId);
            if (overItem) {
                targetStatus = overItem.status;
            }
        }

        if (targetStatus) {
            const item = items.find(i => i.id === itemId);
            // ステータスが変更される場合のみ処理
            if (item && item.status !== targetStatus) {
                // 楽観的UI更新
                setItems(prev => prev.map(i =>
                    i.id === itemId ? { ...i, status: targetStatus! } : i
                ));

                // サーバーアクションの呼び出し
                const result = await updateItemStatus(itemId, targetStatus);
                if (!result.success) {
                    // 失敗時はロールバック
                    setItems(prev => prev.map(i =>
                        i.id === itemId ? { ...i, status: item.status } : i
                    ));
                    alert(`Failed to update status: ${result.error}`);
                }
            }
        }
    };

    const activeItem = activeId
        ? items.find(i => `item-${i.id}` === activeId)
        : null;

    // カート機能用の計算
    const cartItems = items
        .filter(i => selectedIds.includes(i.id))
        .map(i => {
            const part = parts.find(p => p.id === i.part_id);
            return {
                id: i.id,
                part_number: part?.part_number || `Part-${i.part_id}`,
                count: 1
            };
        });

    return (
        <>
            <div className="mb-24">
                {/* ヘッダー行（工程名） */}
                <div className="flex ml-48 border-b border-gray-200 pb-2 mb-2 sticky top-0 bg-gray-50 z-10 shadow-sm">
                    {PROCESSES.map(proc => (
                        <div key={proc.key} className="flex-1 min-w-[140px] px-2 text-center text-xs font-bold text-gray-500 uppercase tracking-widest">
                            {proc.name}
                        </div>
                    ))}
                </div>

                <DndContext
                    sensors={sensors}
                    collisionDetection={closestCorners}
                    onDragStart={handleDragStart}
                    onDragEnd={handleDragEnd}
                >
                    <div className="flex flex-col gap-4">
                        {parts.map(part => (
                            <SwimlaneRow
                                key={part.id}
                                part={part}
                                items={items.filter(i => i.part_id === part.id)}
                                onPreview={(item) => {
                                    const part = parts.find(p => p.id === item.part_id);
                                    setPreviewItem({
                                        ...item,
                                        part_number: part?.part_number
                                    });
                                }}
                            />
                        ))}
                    </div>

                    <DragOverlay>
                        {activeItem ? (
                            <DraggableItem
                                item={activeItem}
                                isOverlay
                                onPreview={() => { }}
                            />
                        ) : null}
                    </DragOverlay>
                </DndContext>
            </div>

            {/* カートUIは一旦省略しないが、スペースの都合で簡易化する場合はここを調整 */}
            {selectedIds.length > 0 && (
                <div className="fixed bottom-8 left-1/2 -translate-x-1/2 bg-gray-900 text-white px-6 py-3 rounded-xl z-50 shadow-xl">
                    <span className="font-bold">{selectedIds.length} items selected</span>
                </div>
            )}

            <CartModal
                isOpen={isCartOpen}
                onClose={() => setIsCartOpen(false)}
                items={cartItems}
                onDownload={() => alert("Zipダウンロードを開始します")}
            />

            <PreviewModal
                isOpen={!!previewItem}
                onClose={() => setPreviewItem(null)}
                partNumber={previewItem?.part_number || ''}
                itemId={previewItem?.id}
                status={previewItem?.status}
                projectId={projectId}
            />
        </>
    );
}
</file>

<file path="package.json">
{
  "name": "sn-923",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@dnd-kit/core": "^6.3.1",
    "@dnd-kit/sortable": "^10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "@react-three/drei": "^10.7.7",
    "@react-three/fiber": "^9.5.0",
    "@tailwindcss/postcss": "^4.1.18",
    "@types/three": "^0.182.0",
    "firebase": "^12.8.0",
    "next": "^16.1.6",
    "react": "^19.2.4",
    "react-dom": "^19.2.4",
    "three": "^0.182.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "@types/react": "^19.2.10",
    "@types/react-dom": "^19.2.3",
    "autoprefixer": "^10.4.23",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.18",
    "typescript": "^5.3.0"
  }
}
</file>

<file path="app/item/[id]/page.tsx">
import { mockStore } from '@/lib/mockStore'
import { updateProcess } from '@/app/actions/updateProcess'
import { consumeItem } from '@/app/actions/consumeItem'
import { reportDefect } from '@/app/actions/reportDefect' // アクションをインポート
import { PROCESSES } from '@/app/constants'
import Link from 'next/link'

export default async function ItemPage(props: { params: Promise<{ id: string }> }) {
  const params = await props.params;
  const id = parseInt(params.id, 10);
  const data = await mockStore.getPartItem(id);

  if (!data) {
    return <div className="p-8">アイテムが見つかりませんでした</div>;
  }

  return (
    <div className="p-8 max-w-2xl mx-auto bg-white shadow-lg rounded-xl mt-10 border border-gray-100">
      <Link href={`/project/${data.parts.project_id}`} className="text-sm text-blue-600 hover:underline mb-6 inline-block font-bold">
        ← プロジェクト進捗に戻る
      </Link>

      <div className="flex justify-between items-start mb-6">
        <h1 className="text-3xl font-black text-gray-900">{data.parts.part_number}</h1>
        <span className={`px-3 py-1 rounded-full text-xs font-bold ${data.status === 'DEFECTIVE' ? 'bg-red-100 text-red-600' : 'bg-blue-100 text-blue-600'}`}>
          ID: {id}
        </span>
      </div>

      {/* ステータス表示 */}
      <div className={`p-4 rounded-lg mb-8 border ${data.status === 'DEFECTIVE' ? 'bg-red-50 border-red-200' : 'bg-blue-50 border-blue-100'}`}>
        <p className="text-sm font-bold text-gray-500 uppercase tracking-wider">Current Status</p>
        <p className={`text-2xl font-black ${data.status === 'DEFECTIVE' ? 'text-red-700' : 'text-blue-800'}`}>
          {PROCESSES.find(p => p.key === data.status)?.name || data.status}
        </p>
      </div>

      <div className="space-y-10">
        {/* 1. 通常の工程更新 */}
        <section>
          <h2 className="text-sm font-bold text-gray-400 uppercase mb-3">工程を進める</h2>
          <form action={async (formData) => {
            'use server'
            const next = formData.get('next') as string;
            await updateProcess(id, next, data.parts.project_id);
          }} className="flex gap-2">
            <select name="next" defaultValue={data.status} className="flex-1 p-3 border rounded-lg font-bold">
              {PROCESSES.map(proc => <option key={proc.key} value={proc.key}>{proc.name}</option>)}
            </select>
            <button className="bg-gray-800 text-white px-6 py-3 rounded-lg font-bold hover:bg-black transition-colors">更新</button>
          </form>
        </section>

        {/* 2. 不良報告セクション（ここが重要） */}
        {data.status !== 'DEFECTIVE' && (
          <section className="p-6 border-2 border-red-200 rounded-2xl bg-red-50/50">
            <h2 className="text-lg font-black text-red-700 mb-2 flex items-center gap-2">
              ⚠️ 不良・再製作の報告
            </h2>
            <p className="text-sm text-red-600 mb-4 font-medium">
              この個体に欠陥がある場合、ここで報告します。この個体は「不良」として記録され、自動的に「未プリント」の新しいジョブが作成されます。
            </p>
            <form action={async (formData) => {
              'use server'
              const reason = formData.get('reason') as string;
              await reportDefect(id, reason);
            }} className="space-y-3">
              <input
                name="reason"
                placeholder="不良理由（例：積層剥離、寸法誤差）"
                className="w-full p-3 border-2 border-red-100 rounded-xl focus:border-red-500 outline-none bg-white font-medium"
                required
              />
              <button className="w-full bg-red-600 text-white font-black py-4 rounded-xl hover:bg-red-700 transition-all shadow-lg active:scale-[0.98]">
                不良を確定し、再製作を依頼
              </button>
            </form>
          </section>
        )}

        {/* 3. 完了処理 */}
        <section>
          <form action={async () => {
            'use server'
            await consumeItem(id);
          }}>
            <button className="w-full border-2 border-green-600 text-green-600 font-black py-4 rounded-xl hover:bg-green-50 transition-colors">
              組み込み完了（ストックから除外）
            </button>
          </form>
        </section>
      </div>
    </div>
  )
}
</file>

<file path="app/print/page.tsx">
'use client';

import React, { useState } from 'react';
import Link from 'next/link';
import { useRouter, useSearchParams } from 'next/navigation';
import { parts as allParts } from '../data'; // 既存のテストデータを使用
import { PROCESSES } from '../constants'; // 工程定義を使用
import { createPrinted } from '../actions/createPrinted';

import { Suspense } from 'react';

// ... imports remain the same

function PrintRegistrationContent() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const projectIdStr = searchParams.get('project_id');
  const projectId = projectIdStr ? parseInt(projectIdStr) : null;

  // プロジェクトIDがあればフィルタリング
  const filteredParts = projectId
    ? allParts.filter(p => p.project_id === projectId)
    : allParts;

  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [selectedPartId, setSelectedPartId] = useState<number>(filteredParts[0]?.id || 0);
  const [quantity, setQuantity] = useState(1);
  const [targetStatus, setTargetStatus] = useState('PRINTED');
  const [isSubmitting, setIsSubmitting] = useState(false);

  // ファイル選択時の処理
  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      setSelectedFile(file);
      // ファイル名に部品番号が含まれていれば自動選択する簡易ロジック
      const matchedPart = filteredParts.find(p => file.name.includes(p.part_number));
      if (matchedPart) setSelectedPartId(matchedPart.id);
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);

    try {
      // サーバーアクションを呼び出してモックデータを更新
      await createPrinted(
        selectedPartId,
        quantity,
        selectedFile?.name || `JOB-${Date.now()}`
      );

      const redirectPath = projectId ? `/project/${projectId}` : '/';
      router.push(redirectPath);
      router.refresh();
    } catch (error) {
      alert('エラーが発生しました');
      console.error(error);
    } finally {
      setIsSubmitting(false);
    }
  };

  const backHref = projectId ? `/project/${projectId}` : '/';

  return (
    <div className="bg-gray-50 min-h-screen p-4 sm:p-8 font-sans">
      <div className="max-w-2xl mx-auto">
        <header className="mb-8">
          <Link href={backHref} className="text-blue-600 hover:underline mb-2 inline-block">
            ← {projectId ? 'プロジェクト別進捗に戻る' : 'ダッシュボードに戻る'}
          </Link>
          <h1 className="text-3xl font-bold text-gray-800">3Dプリント登録</h1>
        </header>

        <form onSubmit={handleSubmit} className="bg-white rounded-xl shadow-lg p-6 space-y-6">
          {/* STLファイルアップロード */}
          <div className="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center hover:border-blue-500 transition-colors">
            <input
              type="file"
              accept=".stl"
              onChange={handleFileChange}
              className="hidden"
              id="stl-upload"
            />
            <label htmlFor="stl-upload" className="cursor-pointer">
              <div className="text-gray-600">
                {selectedFile ? (
                  <span className="font-semibold text-blue-600">{selectedFile.name}</span>
                ) : (
                  "CADから出力したSTLファイルをアップロード"
                )}
              </div>
              <p className="text-sm text-gray-400 mt-2">クリックまたはドラッグ＆ドロップ</p>
            </label>
          </div>

          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
            {/* 部品選択 */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">対象部品</label>
              <select
                value={selectedPartId}
                onChange={(e) => setSelectedPartId(Number(e.target.value))}
                className="w-full border-gray-300 rounded-md shadow-sm p-2 border"
              >
                {filteredParts.map(p => (
                  <option key={p.id} value={p.id}>{p.part_number}</option>
                ))}
              </select>
            </div>

            {/* 数量入力 */}
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">数量</label>
              <input
                type="number"
                min="1"
                value={quantity}
                onChange={(e) => setQuantity(Number(e.target.value))}
                className="w-full border-gray-300 rounded-md shadow-sm p-2 border"
              />
            </div>
          </div>

          {/* ステータス選択 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">登録時のステータス</label>
            <div className="flex gap-4 mt-2">
              {['UNPRINTED', 'PRINTED'].map((status) => (
                <label key={status} className="flex items-center">
                  <input
                    type="radio"
                    name="status"
                    value={status}
                    checked={targetStatus === status}
                    onChange={(e) => setTargetStatus(e.target.value)}
                    className="mr-2"
                  />
                  {PROCESSES.find(p => p.key === status)?.name}
                </label>
              ))}
            </div>
          </div>

          <button
            type="submit"
            disabled={isSubmitting}
            className={`w-full text-white font-bold py-3 px-6 rounded-lg shadow-md transition-colors text-lg ${isSubmitting ? 'bg-gray-400 cursor-not-allowed' : 'bg-blue-600 hover:bg-blue-700'
              }`}
          >
            {isSubmitting ? '登録中...' : 'プリントジョブを登録'}
          </button>
        </form>
      </div>
    </div>
  );
}

export default function PrintRegistrationPage() {
  return (
    <Suspense fallback={<div className="min-h-screen flex items-center justify-center">Loading...</div>}>
      <PrintRegistrationContent />
    </Suspense>
  );
}
</file>

</files>
